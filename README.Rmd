---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  dev = "png",
  dpi = 150,
  fig.height = 6,
  fig.width = 9,
  out.width = "100%"
)
```

# ffc

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![CRAN status](https://www.r-pkg.org/badges/version/ffc)](https://CRAN.R-project.org/package=ffc)
[![R-CMD-check](https://github.com/nicholasjclark/ffc/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/nicholasjclark/ffc/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/nicholasjclark/ffc/graph/badge.svg)](https://app.codecov.io/gh/nicholasjclark/ffc)
<!-- badges: end -->

# ffc

> **F**unctional **F**ore**C**asting

The goal of the `ffc` ðŸ“¦ is to perform functional regression using Generalized Additive Models (GAMs). The package integrates with the extremely flexible [`mgcv`](https://cran.r-project.org/package=mgcv){target="_blank"} package to enable functional responses to be modelled and predicted using a broad range of predictor effects. Key among these types of predictors are *dynamic functional predictors* using a new `fts()` term, which sets up functional predictors whose coefficients are modelled as time-varying. These time-varying coefficients can then be forecasted ahead using a variety of efficient forecasting algorithms, providing unmatched flexibility to model and predict how functional responses change over time.

## Installation

You can install the development version of ffc from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("nicholasjclark/ffc")
```

## A brief example
Load the in-built Queensland Mortality data, which contains the number of deaths per age category over time in the state of Queensland, Australia
```{r, message=FALSE, warning=FALSE}
library(ffc)
library(ggplot2); theme_set(theme_bw())
data('qld_mortality')
head(qld_mortality, 15)
```

Visualise the observed mortality curves over time using the log10 scale
```{r, warning=FALSE}
ggplot(data = qld_mortality,
       aes(x = age,
           y = deaths / population,
           group = year,
           colour = year)) +
  geom_line() +
  facet_wrap(~ sex) +
  scale_colour_viridis_c() +
  labs(y = 'Observed log(Mortality)') +
  scale_y_log10()
```

Fit a model to estimate how the log(mortality) curve changed over time using `deaths` as the outcome and using a time-varying function of `age` as the primary predictor. Using `fts()`, we model the age-death function with a set of `k = 10` thin plate basis functions whose coefficients are allowed to vary over time, where `time = 'year'`. In this model we also allow the time-varying effects to vary among sexes, while ensuring they can be efficiently learned by linking their smoothing parameters. We use the `bam()` engine (as opposed to `gam()`) for parameter estimation, given the large size of the dataset. In future, other engines such as `brm()` and `mvgam()`, will be made available for full luxury Bayesian inference.
```{r}
mod <- ffc_gam(
  deaths ~ 
    offset(log(population)) +
    sex + 
    fts(age, k = 10, bs = 'cr', by = sex,
        time_bs = 'cr', time_k = '15'),
  time = 'year',
  data = qld_mortality,
  family = poisson(),
  engine = 'bam'
)
```

Inspect the model summary; notice in the `Formula` slot how the basis functions are modelled as `by` variables within independent smooths of `year` that share their smoothing parameters
```{r}
summary(mod)
```

View predicted functional curves using a fixed offset (where `population = 1`), which allows us to calculate a standardized rate of mortality
```{r}
newdat <- qld_mortality
newdat$population <- 1
newdat$preds <- predict(
  mod,
  newdata = newdat,
  type = 'response'
)

ggplot(data = newdat,
       aes(x = age,
           y = preds,
           group = year,
           colour = year)) +
  geom_line() +
  facet_wrap(~ sex) +
  scale_colour_viridis_c() +
  labs(y = 'Expected log10(Mortality)') +
  scale_y_log10()
```

The time-varying coefficients (and their Standard Errors) can be extracted into a `tidy` format using `fts_coefs()`, which will facilitate the use of time series models to enable efficient forecasting of the entire curve into the future
```{r}
functional_coefs <- fts_coefs(mod)
functional_coefs
```

There is no automatic plotting function yet to visualise these time-varying coefficients, but for now we can use a bit of `ggplot` to get this done
```{r}
ggplot(
  data = functional_coefs,
  aes(x = year,
      y = .estimate,
      colour = .basis)
) +
  geom_ribbon(
    mapping = aes(ymax = .estimate + 2 * .se,
                  ymin = .estimate - 2 * .se,
                  fill = .basis),
    show.legend = FALSE
  ) +
  geom_line(
    show.legend = FALSE
  ) +
  facet_wrap(
    ~.basis, 
    scales = 'free_y',
    ncol = 4
  ) +
  labs(
    y = 'Coefficient estimate',
    x = 'Year'
  )
```

Clearly there is a lot of structure and dependence here, suggesting that a dynamic factor model fitted to these coefficient time series would be valuable for creating functional forecasts. More on that to come!

## Getting help
If you encounter a clear bug, please file an issue with a minimal reproducible example on [GitHub](https://github.com/nicholasjclark/ffc/issues)

## License
The `ffc` project is licensed under an `MIT` open source license
