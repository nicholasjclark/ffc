[{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"project-overview","dir":"","previous_headings":"","what":"Project Overview","title":"Claude Code Assistant Instructions for ffc Package","text":"ffc (Functional ForeCasting) package performs functional regression using GAMs time-varying functional coefficients, integrating mgcv Stan dynamic factor modeling.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"directory-structure","dir":"","previous_headings":"","what":"Directory Structure","title":"Claude Code Assistant Instructions for ffc Package","text":"R/ - R source code functions inst/stan/ - Stan model files (ardf.stan, vardf.stan, gpdf.stan) tests/testthat/ - Test files man/ - Auto-generated documentation via roxygen2","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"object-system","dir":"","previous_headings":"","what":"Object System","title":"Claude Code Assistant Instructions for ffc Package","text":"package uses S3 object system classes: - ffc_gam - Main model class - fts_ts - Time series coefficient class - Methods: print, predict, forecast, autoplot, model.frame","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"testing","dir":"","previous_headings":"Development Commands","what":"Testing","title":"Claude Code Assistant Instructions for ffc Package","text":"","code":"# ALWAYS load functions before testing Rscript -e \"devtools::load_all(); testthat::test_file('tests/testthat/test_fts.R')\"  # Run specific test by description (NOT by filter) Rscript -e \"devtools::load_all(); testthat::test_file('tests/testthat/test_fts.R', desc = 'specific test description')\"  # Run all tests Rscript -e \"devtools::test()\""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"documentation","dir":"","previous_headings":"Development Commands","what":"Documentation","title":"Claude Code Assistant Instructions for ffc Package","text":"","code":"# Generate/update roxygen2 documentation Rscript -e \"devtools::document()\"  # Build pkgdown site Rscript -e \"pkgdown::build_site()\""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"pkgdown-reference-management","dir":"","previous_headings":"Development Commands","what":"pkgdown Reference Management","title":"Claude Code Assistant Instructions for ffc Package","text":"exported functions must assigned reference section _pkgdown.yml Core Functions: main modeling functions (ffc_gam, fts) Model Methods: predict, forecast, model.frame methods Coefficient Extraction: coefficient-related functions Forecasting Models: ARDF, GPDF, VARDF Integration fabletools: fable conversion functions Data: datasets (growth_data, qld_mortality, elnino_sst) Re-exported Functions: functions packages function doesnâ€™t fit existing sections, create new appropriate section Functions reference index cause pkgdown build errors","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"pkgdown-articles-management","dir":"","previous_headings":"Development Commands","what":"pkgdown Articles Management","title":"Claude Code Assistant Instructions for ffc Package","text":"vignettes must listed articles section _pkgdown.yml Individual vignette name without .Rmd extension (e.g., elnino-forecasting) Pattern matching starts_with() grouped vignettes Missing vignettes index cause pkgdown build errors","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"package-checking","dir":"","previous_headings":"Development Commands","what":"Package Checking","title":"Claude Code Assistant Instructions for ffc Package","text":"","code":"# Check package for errors, warnings, and notes Rscript -e \"devtools::check()\""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"stan-model-management","dir":"","previous_headings":"Development Commands","what":"Stan Model Management","title":"Claude Code Assistant Instructions for ffc Package","text":"","code":"# After modifying .stan files in inst/stan/: Rscript -e \"rstantools::rstan_config(); devtools::document()\"  # Then reinstall package R CMD INSTALL --preclean --no-multiarch ."},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"r-code-style","dir":"","previous_headings":"Code Standards","what":"R Code Style","title":"Claude Code Assistant Instructions for ffc Package","text":"Tidyverse style guide Line length: 80 characters maximum Function names: snake_case, prefer shorter names Assignment: Use <- = Indentation: 2 spaces","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"documentation-1","dir":"","previous_headings":"Code Standards","what":"Documentation","title":"Claude Code Assistant Instructions for ffc Package","text":"Use roxygen2 tags functions Vignettes demonstrate -depth use cases pkgdown site provides comprehensive documentation README provides high level overview roxygen2 examples demonstrate simpler use cases","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"comments","dir":"","previous_headings":"Code Standards","what":"Comments","title":"Claude Code Assistant Instructions for ffc Package","text":"Use sentence case, avoid CAPS Add # Reason: comments complex logic Keep professional self-contained NEVER reference development process, discussions, existing code plans, implementation notes Comments explain , development history meta-information","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"test-requirements","dir":"","previous_headings":"Testing Strategy","what":"Test Requirements","title":"Claude Code Assistant Instructions for ffc Package","text":"test errors warnings allowed Always devtools::load_all() testing Use desc argument selective test execution, filter Add tests appropriate existing test files","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"testthat-guidelines","dir":"","previous_headings":"Testing Strategy","what":"testthat Guidelines","title":"Claude Code Assistant Instructions for ffc Package","text":"Expectation functions info argument Add descriptive comments expectations instead try(), tryCatch(), skip() tests wrapper functions fix failing tests Update existing tests logic changes","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"validation-patterns","dir":"","previous_headings":"","what":"Validation Patterns","title":"Claude Code Assistant Instructions for ffc Package","text":"","code":"# Input validation checkmate::assert_*()  # Error formatting insight::format_error()  # Warning formatting   insight::format_warning()  # One-time session warnings if (!identical(Sys.getenv(\"TESTTHAT\"), \"true\")) {   rlang::warn(\"message\", .frequency = \"once\") }"},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"message-standards","dir":"","previous_headings":"Validation Patterns","what":"Message Standards","title":"Claude Code Assistant Instructions for ffc Package","text":"Use {.field parameter_name} parameter highlighting Include suggested solutions errors Provide context constraints","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"branch-management","dir":"","previous_headings":"Git Workflow","what":"Branch Management","title":"Claude Code Assistant Instructions for ffc Package","text":"Descriptive branch names: feature/brms-integration Branch main/master Keep branches focused Use gh CLI GitHub interactions","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"commit-standards","dir":"","previous_headings":"Git Workflow","what":"Commit Standards","title":"Claude Code Assistant Instructions for ffc Package","text":"mention Claude AI assistance commits","code":"Brief description (50 chars max)  - What was changed - Why it was necessary - Implementation notes"},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"pre-commit-workflow","dir":"","previous_headings":"Git Workflow","what":"Pre-commit Workflow","title":"Claude Code Assistant Instructions for ffc Package","text":"Check git status Stage appropriate files Write clear commit messages","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"compilation-workflow","dir":"","previous_headings":"Stan Development Notes","what":"Compilation Workflow","title":"Claude Code Assistant Instructions for ffc Package","text":"Edit .stan files inst/stan/ Run rstantools::rstan_config() update infrastructure Run devtools::document() regenerate interfaces Reinstall package R CMD INSTALL --preclean ---multiarch . Test compilation sampling","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"stan-code-patterns","dir":"","previous_headings":"Stan Development Notes","what":"Stan Code Patterns","title":"Claude Code Assistant Instructions for ffc Package","text":"Precompiled models accessed via stanmodels$model_name Use vectorized operations efficiency Factor models use lower-triangular loading matrices Data preparation must match Stan data block exactly","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"adding-documentation","dir":"","previous_headings":"Common Tasks","what":"Adding Documentation","title":"Claude Code Assistant Instructions for ffc Package","text":"Update roxygen2 comments R files Run devtools::document() Check generated man pages Update vignettes needed","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"streamlining-predictions","dir":"","previous_headings":"Common Tasks","what":"Streamlining Predictions","title":"Claude Code Assistant Instructions for ffc Package","text":"Modify predict methods R/predict.R Ensure S3 dispatch works correctly Update tests existing test files Document new parameters","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"adding-use-cases","dir":"","previous_headings":"Common Tasks","what":"Adding Use Cases","title":"Claude Code Assistant Instructions for ffc Package","text":"Create vignettes complex examples Add simple examples roxygen2 blocks Update README overview changes","code":""},{"path":"https://nicholasjclark.github.io/ffc/CLAUDE.html","id":"important-constraints","dir":"","previous_headings":"","what":"Important Constraints","title":"Claude Code Assistant Instructions for ffc Package","text":"Zero tolerance test failures warnings Maintain tidyverse style (80 char lines) Always load functions testing Use existing test files possible Document exported functions","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributing to ffc","title":"Contributing to ffc","text":"outlines propose change ffc ðŸ“¦. detailed discussion contributing tidyverse packages, please see development contributing guide code review principles.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to ffc","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means â€™ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to ffc","text":"want make bigger change, â€™s good idea first file issue make sure someone team agrees â€™s needed. â€™ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See guide create great issue advice.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to ffc","text":"Fork package clone onto computer. havenâ€™t done , recommend using usethis::create_from_github(\"nicholasjclark/ffc\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesnâ€™t pass cleanly, â€™s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e.Â just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to ffc","text":"New code follow tidyverse style guide. can use styler package apply styles, please donâ€™t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributing to ffc","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributing to ffc","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing othersâ€™ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributing to ffc","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributing to ffc","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributing to ffc","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@posit.co. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributing to ffc","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributing to ffc","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributing to ffc","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributing to ffc","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributing to ffc","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://nicholasjclark.github.io/ffc/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributing to ffc","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozillaâ€™s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://nicholasjclark.github.io/ffc/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 ffc authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (â€œSoftwareâ€), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED â€œâ€, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Motorcycle crash dynamics involve complex patterns mean acceleration variability change dramatically time impact events. Traditional Gaussian regression assumes constant variance, potentially missing critical safety insights periods extreme unpredictable forces. vignette demonstrates distributional regression ffc package addresses challenges : Time-varying location parameters capturing evolving mean acceleration patterns Time-varying scale parameters modeling heteroskedasticity impact phases Rolling forecast evaluation robust model validation Comprehensive uncertainty quantification safety applications","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"the-crash-dynamics-challenge","dir":"Articles","previous_headings":"Introduction","what":"The crash dynamics challenge","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Motorcycle crash acceleration data presents unique modeling challenges: Non-constant variance different impact phases Complex temporal evolution mean variability Need predict typical extreme force scenarios Critical safety implications requiring proper uncertainty bounds","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"our-approach-distributional-gams-with-functional-coefficients","dir":"Articles","previous_headings":"Introduction","what":"Our approach: distributional GAMs with functional coefficients","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"ffc package treats location scale smooth functions evolve time. combining mgcv distributional families functional regression, can: Model time-varying mean acceleration trends Capture evolving variance patterns throughout crash sequences Generate probabilistic forecasts parameter-specific uncertainty Validate predictions using rolling forecast techniques","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"data-exploration","dir":"Articles","previous_headings":"","what":"Data exploration","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"â€™ll use classic motorcycle crash dataset MASS, representing head acceleration measurements simulated motorcycle crashes:","code":"data(mcycle, package = \"MASS\") mcycle$index <- 1:NROW(mcycle)  # Check data structure glimpse(mcycle) #> Rows: 133 #> Columns: 3 #> $ times <dbl> 2.4, 2.6, 3.2, 3.6, 4.0, 6.2, 6.6, 6.8, 7.8, 8.2, 8.8, 8.8, 9.6,â€¦ #> $ accel <dbl> 0.0, -1.3, -2.7, 0.0, -2.7, -2.7, -2.7, -1.3, -2.7, -2.7, -1.3, â€¦ #> $ index <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1â€¦"},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"visualizing-acceleration-patterns","dir":"Articles","previous_headings":"Data exploration","what":"Visualizing acceleration patterns","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Head acceleration measurements showing clear heteroskedasticity time. data shows low variance impact, extreme variance crash, moderate variance rebound phase.","code":"ggplot(mcycle, aes(x = index, y = accel)) +   geom_point(alpha = 0.7, size = 2) +   geom_line() +   geom_vline(xintercept = 110, linetype = \"dashed\", color = \"darkred\", alpha = 0.7) +   labs(     x = \"Time Index\",      y = \"Head Acceleration\",     title = \"Motorcycle crash data: heteroskedastic acceleration patterns\"   )"},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"identifying-variance-patterns","dir":"Articles","previous_headings":"Data exploration","what":"Identifying variance patterns","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Letâ€™s examine variance changes across different phases crash sequence: Moving variance reveals dramatic changes acceleration variability time. moving variance peaks dramatically crash phase, confirming constant variance assumptions inappropriate data.","code":"# Calculate moving variance with overlapping windows window_size <- 15 mcycle$moving_var <- NA  for (i in (window_size + 1):(nrow(mcycle) - window_size)) {   window_data <- mcycle$accel[(i - window_size):(i + window_size)]   mcycle$moving_var[i] <- var(window_data, na.rm = TRUE) }  ggplot(mcycle, aes(x = index)) +   geom_line(aes(y = moving_var), color = \"darkred\", linewidth = 1.2) +   geom_point(aes(y = moving_var), color = \"darkred\", alpha = 0.7) +   labs(     x = \"Time Index\",     y = \"Moving variance\",     title = \"Time-varying variance in motorcycle crash acceleration\"   )"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"train-test-split-for-validation","dir":"Articles","previous_headings":"Modeling with distributional GAMs","what":"Train-test split for validation","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"â€™ll use early crash data training reserve later impact phases validation:","code":"mcycle_train <- mcycle |>   dplyr::filter(index < 110) mcycle_test <- mcycle |>   dplyr::filter(index >= 110)"},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"the-distributional-model-specification","dir":"Articles","previous_headings":"Modeling with distributional GAMs","what":"The distributional model specification","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Now letâ€™s fit model allow us forecast changes mean variance. key innovation using gaulss() model location scale parameters functional time series:","code":"mcycle_gaulss_model <- ffc_gam(   list(     # Location parameter: time-varying mean acceleration       accel ~ fts(index, mean_only = TRUE, time_k = 25),          # Scale parameter: time-varying variance     ~ fts(index, mean_only = TRUE, time_k = 25)   ),   family = gaulss(),   data = mcycle_train,   time = \"index\" )"},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"understanding-the-model-structure","dir":"Articles","previous_headings":"Modeling with distributional GAMs","what":"Understanding the model structure","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"model decomposes crash dynamics : Location parameter: Smooth time-varying mean acceleration Scale parameter: Time-varying standard deviation modeling heteroskedasticity gaulss() family uses log-link scale parameter, ensuring positive variance estimates throughout crash sequence.","code":"summary(mcycle_gaulss_model) #>  #> Family: gaulss  #> Link function: identity logb  #>  #> Formula: #> accel ~ s(index, by = location_fts_index1_mean, bs = \"ts\", k = 25,  #>     m = 2) #> ~s(index, by = scale_fts_index1_mean, bs = \"ts\", k = 25, m = 2) #>  #> Parametric coefficients: #>                Estimate Std. Error z value Pr(>|z|)     #> (Intercept)   -31.14284    2.18787  -14.23   <2e-16 *** #> (Intercept).1   2.55943    0.07069   36.21   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Approximate significance of smooth terms: #>                                      edf Ref.df Chi.sq p-value     #> s(index):location_fts_index1_mean 10.440     24  627.4  <2e-16 *** #> s.1(index):scale_fts_index1_mean   4.334     24  282.8  <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Deviance explained = 99.3% #> -REML = 476.13  Scale est. = 1         n = 109"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"visualizing-fitted-trends-and-variance","dir":"Articles","previous_headings":"Model diagnostics and interpretation","what":"Visualizing fitted trends and variance","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"can examine model captures mean trends changing variance: Fitted location scale parameters reveal distinct temporal patterns crash dynamics. location parameter captures mean acceleration trajectory scale parameter adapts varying uncertainty levels throughout crash sequence.","code":"# Extract time-varying coefficients for both parameters fts_results <- fts_coefs(mcycle_gaulss_model, summary = FALSE)  autoplot(fts_results) +   labs(     title = \"Time-varying distributional parameters\",     x = \"Time Index\",     y = \"Coefficient Value\"   )"},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"extracting-parameter-specific-coefficients","dir":"Articles","previous_headings":"Model diagnostics and interpretation","what":"Extracting parameter-specific coefficients","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"functional coefficients reveal underlying dynamics distributional parameter:","code":"# View coefficient structure fts_results #> # A tibble: 5,450 Ã— 6 #>    .basis                   .parameter .time .estimate .realisation index #>  * <chr>                    <chr>      <int>     <dbl>        <int> <int> #>  1 location_fts_index1_mean location       1      27.8            1     1 #>  2 location_fts_index1_mean location       2      27.2            1     2 #>  3 location_fts_index1_mean location       3      26.7            1     3 #>  4 location_fts_index1_mean location       4      26.3            1     4 #>  5 location_fts_index1_mean location       5      26.2            1     5 #>  6 location_fts_index1_mean location       6      26.2            1     6 #>  7 location_fts_index1_mean location       7      26.1            1     7 #>  8 location_fts_index1_mean location       8      26.0            1     8 #>  9 location_fts_index1_mean location       9      25.8            1     9 #> 10 location_fts_index1_mean location      10      25.4            1    10 #> # â„¹ 5,440 more rows  # Summary statistics by parameter fts_results |>   as_tibble() |>   group_by(.parameter, .basis) |>   summarise(     mean_coef = mean(.estimate),     sd_coef = sd(.estimate),     .groups = \"drop\"   ) #> # A tibble: 2 Ã— 4 #>   .parameter .basis                   mean_coef sd_coef #>   <chr>      <chr>                        <dbl>   <dbl> #> 1 location   location_fts_index1_mean -2.02e-12   44.9  #> 2 scale      scale_fts_index1_mean     5.22e-15    1.17"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"single-forecast-demonstration","dir":"Articles","previous_headings":"Forecasting distributional models","what":"Single forecast demonstration","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Generate forecasts provide mean predictions uncertainty intervals based evolving variance structure:","code":"fc_single <- forecast(   mcycle_gaulss_model,   newdata = mcycle_test,   model = \"ENS\",   mean_model = \"ENS\" )  # Examine forecast structure fc_single #> # A tibble: 24 Ã— 6 #>    .estimate .error  .q2.5  .q10  .q90 .q97.5 #>        <dbl>  <dbl>  <dbl> <dbl> <dbl>  <dbl> #>  1     16.2    26.0  -52.8 -28.1  69.5   94.0 #>  2     26.4    28.3  -59.2 -29.9  78.8  120.  #>  3     17.8    36.2 -110.  -45.4  86.8  132.  #>  4     35.7    29.7  -59.5 -15.3 103.   126.  #>  5     17.6    30.9  -52.0 -28.2  78.7  113.  #>  6      7.02   33.6  -63.9 -43.0  72.3  125.  #>  7     15.3    34.9 -112.  -50.1  94.5  119.  #>  8      5.44   30.4  -96.6 -52.9  71.3  102.  #>  9     17.5    24.4  -61.0 -31.5  64.2   94.5 #> 10     21.4    28.6 -104.  -42.8  64.4  115.  #> # â„¹ 14 more rows"},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"visualizing-distributional-forecasts","dir":"Articles","previous_headings":"Forecasting distributional models","what":"Visualizing distributional forecasts","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Distributional forecasts capture mean trends evolving uncertainty time-varying scale parameter. widening prediction intervals test period reflect increasing uncertainty forecast training data, natural consequence parameter extrapolation.","code":"# Combine training and forecast data for visualization forecast_plot_data <- mcycle_train |>   as_tibble() |>   mutate(type = \"observed\") |>   bind_rows(     mcycle_test |>       as_tibble() |>       bind_cols(fc_single) |>       mutate(type = \"forecast\")   )  ggplot(forecast_plot_data, aes(x = index, y = accel)) +   geom_point(data = filter(forecast_plot_data, type == \"observed\"),              alpha = 0.7, size = 2) +   geom_ribbon(data = filter(forecast_plot_data, type == \"forecast\"),               aes(ymin = .q2.5, ymax = .q97.5),               fill = \"darkred\", alpha = 0.2) +   geom_ribbon(data = filter(forecast_plot_data, type == \"forecast\"),               aes(ymin = .q10, ymax = .q90),               fill = \"darkred\", alpha = 0.3) +   geom_line(data = filter(forecast_plot_data, type == \"forecast\"),             aes(y = .estimate),             colour = \"darkred\", linewidth = 1.2) +   geom_point(data = filter(forecast_plot_data, type == \"forecast\"),              color = \"black\", size = 2) +   labs(     title = \"Distributional GAM forecasts for motorcycle crash acceleration\",     x = \"Time Index\",      y = \"Head Acceleration\"   )"},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"coefficient-forecast-inspection","dir":"Articles","previous_headings":"","what":"Coefficient forecast inspection","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"can also forecast functional coefficients understand underlying parameters evolve: Forecasted functional coefficients show parameter-specific evolution patterns quantified uncertainty. forecasts parameters reflect underlying nonlinear dynamics captured exponential smoothing random walk ensemble model.","code":"# Forecast the coefficients to the test period coef_forecast_raw <- forecast(   fts_results,   h = nrow(mcycle_test),   model = \"ENS\" )  # Summarize coefficient forecasts coef_forecast <- coef_forecast_raw |>   as_tibble() |>   group_by(.basis, .time) |>   summarise(     .estimate = mean(.sim),     .q2.5 = quantile(.sim, 0.025),     .q97.5 = quantile(.sim, 0.975),     .groups = \"drop\"   )  # Summarize training coefficients fts_coefs_summary <- fts_results |>   as_tibble() |>   group_by(.basis, .time) |>   summarise(     .estimate = mean(.estimate),     .groups = \"drop\"   )  # Visualize coefficient evolution and forecasts ggplot() +   geom_line(data = fts_coefs_summary,             aes(x = .time, y = .estimate, color = .basis),             linewidth = 1) +   geom_ribbon(data = coef_forecast,               aes(x = .time, ymin = .q2.5, ymax = .q97.5, fill = .basis),               alpha = 0.2) +   geom_line(data = coef_forecast,             aes(x = .time, y = .estimate, color = .basis),             linewidth = 1.2) +   facet_wrap(~ .basis, scales = \"free_y\") +   labs(     title = \"Functional coefficients: training vs forecasted\",     x = \"Time Index\",      y = \"Coefficient Value\"   ) +   theme(legend.position = \"none\")"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"understanding-rolling-forecast-evaluation","dir":"Articles","previous_headings":"Rolling forecast evaluation","what":"Understanding rolling forecast evaluation","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Rolling forecast evaluation, also known time series cross-validation, provides robust assessment model performance traditional train-test splits. Instead evaluating predictions single time point, approach tests well model performs making forecasts many different origins throughout time series. mimics real-world forecasting scenarios continuously update models new data generate fresh predictions. method works sliding fixed-size training window time series. position, fit model using data within window, generate forecasts specified number steps ahead (forecast horizon). advancing window position systematically (determined step size), obtain multiple sets forecasts can evaluated actual observed values. reveals whether model maintains consistent performance across different time periods data conditions. distributional models like , rolling evaluation particularly valuable tests whether prediction intervals remain well-calibrated throughout entire time series. safety-critical applications crash analysis, need confidence uncertainty estimates reliable just average, consistently across phases crash timeline.","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"rolling-forecast-parameters","dir":"Articles","previous_headings":"Rolling forecast evaluation","what":"Rolling forecast parameters","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"choice window size reflects trade-enough data reliably estimate model parameters maintaining enough forecast origins robust evaluation. window 50 observations captures sufficient crash dynamics step size 10 provides reasonable coverage timeline without excessive computational burden. 10-step forecast horizon tests modelâ€™s ability predict immediate future, relevant understanding crash dynamics conditions can change rapidly.","code":"# Use 50 observations for each training window - enough data to estimate # time-varying parameters while allowing multiple forecast origins window_size <- 50  # Predict 10 steps ahead from each origin - tests short-term accuracy # relevant for crash dynamics without extending into highly uncertain territory   forecast_horizon <- 10  # Advance forecast origin by 10 steps between evaluations - balances # computational cost with evaluation thoroughness step_size <- 10  # Calculate where each forecast origin will be positioned max_start <- nrow(mcycle) - forecast_horizon forecast_starts <- seq(1, max(1, max_start - window_size), by = step_size)"},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"executing-rolling-forecasts","dir":"Articles","previous_headings":"Rolling forecast evaluation","what":"Executing rolling forecasts","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"rolling forecast loop systematically moves time series, fitting fresh model origin generating predictions subsequent time points. process simulates forecasting works practice, periodically retrain models latest available data. iteration loop represents realistic forecasting scenario historical data certain point (training window) must predict happens next. metadata track allows us analyze performance varies forecast origin horizon.","code":"# List to accumulate results from each forecast origin rolling_results <- list()  # Loop through each forecast origin position for (i in seq_along(forecast_starts)) {   # Define the training window boundaries   start_idx <- forecast_starts[i]   end_idx <- min(start_idx + window_size - 1, nrow(mcycle))    # Extract training data for this window   train_data <- mcycle[start_idx:end_idx, ]      # Define the test period immediately following the training window   test_start <- end_idx + 1   test_end <- min(test_start + forecast_horizon - 1, nrow(mcycle))    # Only proceed if we have enough data for the full test period   if (test_end <= nrow(mcycle)) {     test_data <- mcycle[test_start:test_end, ]      # Fit a distributional model to the training window     # Using mean_only = TRUE for computational efficiency in the loop     roll_model <- ffc_gam(       list(         accel ~ fts(index, mean_only = TRUE, time_k = 10),         ~ fts(index, mean_only = TRUE, time_k = 10)       ),       family = gaulss(),       data = train_data,       time = \"index\"     )      # Generate forecasts for the test period using ensemble method     roll_forecast <- forecast(       roll_model,       newdata = test_data,       model = \"ENS\"     )      # Combine actual values with predictions and add tracking metadata     rolling_results[[i]] <- test_data |>       bind_cols(roll_forecast) |>       mutate(         forecast_origin = i,         train_start = start_idx,         train_end = end_idx,         horizon = 1:nrow(test_data)       )   } }  # Combine all forecast results into a single data frame for analysis rolling_forecasts <- bind_rows(rolling_results)"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"forecast-accuracy-metrics","dir":"Articles","previous_headings":"Rolling forecast performance analysis","what":"Forecast accuracy metrics","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"evaluate distributional forecasts comprehensively, calculate point forecast accuracy measures coverage statistics prediction intervals. Coverage refers proportion actual observations fall within predicted intervals. well-calibrated 95% prediction interval contain true value approximately 95% time across many forecasts. coverage substantially lower, model overconfident; higher, unnecessarily conservative.","code":"# Calculate comprehensive performance metrics for each forecast rolling_forecasts <- rolling_forecasts |>   mutate(     # Point forecast errors     forecast_error = accel - .estimate,     abs_error = abs(forecast_error),     squared_error = forecast_error^2,          # Coverage indicators: TRUE if actual value falls within interval     coverage_95 = (accel >= .q2.5) & (accel <= .q97.5),     coverage_80 = (accel >= .q10) & (accel <= .q90),          # Interval widths to assess uncertainty magnitude     interval_width_95 = .q97.5 - .q2.5,     interval_width_80 = .q90 - .q10   )  # Performance by forecast horizon horizon_stats <- rolling_forecasts |>   group_by(horizon) |>   summarise(     n_forecasts = n(),     mae = mean(abs_error, na.rm = TRUE),     rmse = sqrt(mean(squared_error, na.rm = TRUE)),     coverage_95 = mean(coverage_95, na.rm = TRUE),     coverage_80 = mean(coverage_80, na.rm = TRUE),     avg_width_95 = mean(interval_width_95, na.rm = TRUE),     avg_width_80 = mean(interval_width_80, na.rm = TRUE),     .groups = 'drop'   )  horizon_stats #> # A tibble: 10 Ã— 8 #>    horizon n_forecasts   mae  rmse coverage_95 coverage_80 avg_width_95 #>      <int>       <int> <dbl> <dbl>       <dbl>       <dbl>        <dbl> #>  1       1           8  28.7  40.0       0.75        0.75          139. #>  2       2           8  41.3  52.4       0.75        0.625         138. #>  3       3           8  24.2  31.5       0.875       0.875         135. #>  4       4           8  26.3  29.6       1           0.75          139. #>  5       5           8  26.6  36.4       0.875       0.875         141. #>  6       6           8  38.1  52.9       0.75        0.625         140. #>  7       7           8  27.0  50.0       0.875       0.75          144. #>  8       8           8  23.3  27.8       1           0.875         135. #>  9       9           8  44.8  56.5       0.75        0.5           138. #> 10      10           8  29.6  38.4       0.75        0.625         140. #> # â„¹ 1 more variable: avg_width_80 <dbl>  # Overall performance summary   overall_stats <- rolling_forecasts |>   summarise(     total_forecasts = n(),     overall_mae = mean(abs_error, na.rm = TRUE),     overall_rmse = sqrt(mean(squared_error, na.rm = TRUE)),     overall_coverage_95 = mean(coverage_95, na.rm = TRUE),     overall_coverage_80 = mean(coverage_80, na.rm = TRUE)   )  cat(\"- 95% coverage:\", round(overall_stats$overall_coverage_95 * 100, 1), \"%\\n\") #> - 95% coverage: 83.8 % cat(\"- 80% coverage:\", round(overall_stats$overall_coverage_80 * 100, 1), \"%\\n\") #> - 80% coverage: 72.5 %"},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"rolling-forecast-visualization","dir":"Articles","previous_headings":"Rolling forecast performance analysis","what":"Rolling forecast visualization","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Rolling forecast evaluation reveals consistent prediction performance across different crash phases. plot shows forecasts (red points) 80% prediction intervals capturing observed values across diverse crash phases, demonstrating consistent model performance.","code":"# Visualize rolling forecasts over the full time series ggplot() +   geom_point(data = mcycle, aes(x = index, y = accel),              alpha = 0.4, size = 1) +   geom_line(data = mcycle, aes(x = index, y = accel),              alpha = 0.4) +   geom_point(data = rolling_forecasts,              aes(x = index, y = .estimate),              color = \"darkred\", size = 1.5, alpha = 0.8) +   geom_errorbar(data = rolling_forecasts,                 aes(x = index, ymin = .q10, ymax = .q90),                 color = \"darkred\", alpha = 0.6, width = 0.5) +   geom_segment(data = rolling_forecasts,                aes(x = index, xend = index, y = accel, yend = .estimate),                color = \"darkblue\", alpha = 0.3, linetype = \"dashed\") +   labs(     title = \"Rolling forecast evaluation across crash timeline\",     x = \"Time Index\",      y = \"Head Acceleration\"   )"},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"coverage-evolution-analysis","dir":"Articles","previous_headings":"Rolling forecast performance analysis","what":"Coverage evolution analysis","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Cumulative coverage rates demonstrate well-calibrated prediction intervals throughout evaluation. cumulative coverage rates fluctuate across time index, revealing periods model overconfident conservative, stabilizing closer nominal levels.","code":"# Track coverage evolution over evaluation period coverage_data <- rolling_forecasts |>   arrange(index) |>   mutate(     running_coverage_95 = cumsum(coverage_95) / row_number(),     running_coverage_80 = cumsum(coverage_80) / row_number()   )  ggplot(coverage_data, aes(x = index)) +   geom_line(aes(y = running_coverage_95), color = \"darkred\", linewidth = 1.2) +   geom_line(aes(y = running_coverage_80), color = \"darkblue\", linewidth = 1.2) +   geom_hline(yintercept = 0.95, linetype = \"dashed\", color = \"darkred\", alpha = 0.7) +   geom_hline(yintercept = 0.80, linetype = \"dashed\", color = \"darkblue\", alpha = 0.7) +   scale_y_continuous(labels = scales::percent_format()) +   labs(     title = \"Cumulative coverage rates validate interval calibration\",     x = \"Time Index\",     y = \"Cumulative Coverage Rate\"   )"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"when-to-use-distributional-regression","dir":"Articles","previous_headings":"Key insights and best practices","what":"When to use distributional regression","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Distributional regression ffc essential : Data exhibits clear heteroskedasticity (changing variance time) mean trends uncertainty evolution matter interpretation Risk assessment requires proper uncertainty bounds Traditional constant-variance assumptions violated Key implementation considerations: Use list formula syntax: list(response ~ fts(...), ~ fts(...)) Choose appropriate distributional families (gaulss(), twlss(), betar()) Scale parameter automatically uses log-link positivity Different time_k values can used different parameters","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"distributional-forecasting-advantages","dir":"Articles","previous_headings":"Key insights and best practices","what":"Distributional forecasting advantages","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"time-varying distributional approach excels : Traditional homoskedastic models miss variance patterns Parameter-specific uncertainty quantification needed Rolling validation reveals model robustness across conditions Safety applications require conservative interval estimation detailed guidance distributional families mgcv, see Wood (2017).","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"vignette demonstrated advanced distributional regression techniques motorcycle crash data: Time-varying location scale parameters capture evolving crash dynamics Functional time series coefficients provide interpretable parameter evolution Rolling forecast evaluation ensures robust model validation Proper uncertainty quantification enables safety-critical applications ffc package integrates distributional modeling seamlessly functional forecasting: - List formula syntax multi-parameter specifications - Parameter-specific coefficient extraction forecasting - Comprehensive validation rolling forecast techniques - Integration mgcv distributional families","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/distributional-regression.html","id":"further-reading","dir":"Articles","previous_headings":"Conclusion","what":"Further reading","title":"Distributional Regression for Motorcycle Crash Data with Time-Varying Location and Scale Parameters","text":"Wood (2017): Generalized Additive Models: Introduction R Rigby & Stasinopoulos (2005): Generalized additive models location, scale shape Hyndman & Athanasopoulos (2021): Forecasting: Principles Practice mgcv distributional families documentation","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"Sea surface temperature (SST) tropical Pacific exhibits complex seasonal patterns evolve dramatically El NiÃ±o-Southern Oscillation (ENSO) events. Traditional time series methods often struggle capture cyclic seasonal structure inter-annual variability characterizes ocean-atmosphere interactions. vignette demonstrates functional forecasting ffc package addresses challenges : Cyclic cubic splines naturally handle periodic seasonal patterns Gaussian Process Dynamic Factor (GPDF) models sophisticated multivariate forecasting Innovative validation techniques","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"the-forecasting-challenge","dir":"Articles","previous_headings":"Introduction","what":"The forecasting challenge","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"El NiÃ±o SST data presents unique modeling challenges: - Strong seasonal cycles must connect smoothly year boundaries - Inter-annual variability driven complex ocean-atmosphere coupling - Non-stationary patterns ENSO transitions - Multiple correlated time series functional coefficients","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"our-approach-functional-coefficients-meet-dynamic-factors","dir":"Articles","previous_headings":"Introduction","what":"Our approach: functional coefficients meet dynamic factors","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"ffc package treats seasonal patterns smooth functions whose shapes evolve time. combining mgcv GAM-based functional regression Stan-powered dynamic factor models, can: - Preserve seasonal continuity allowing flexible evolution - Capture shared trends across multiple coefficient series - Generate probabilistic forecasts proper uncertainty quantification - Validate predictions using state---art functional data metrics","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"data-exploration","dir":"Articles","previous_headings":"","what":"Data exploration","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"â€™ll use monthly SST data El NiÃ±o regions 1 2, spanning 1982-2018:","code":"data(\"elnino_sst\") glimpse(elnino_sst) #> Rows: 444 #> Columns: 3 #> Key: month [12] #> $ year        <int> 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991â€¦ #> $ month       <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1â€¦ #> $ temperature <dbl> 24.29, 27.42, 24.18, 23.59, 24.61, 25.30, 24.64, 24.09, 24â€¦  # Check temporal coverage cat(\"Years covered:\", min(elnino_sst$year), \"-\", max(elnino_sst$year), \"\\n\") #> Years covered: 1982 - 2018 cat(\"Total observations:\", nrow(elnino_sst), \"\\n\") #> Total observations: 444 cat(\"Monthly measurements per year:\", elnino_sst |>      index_by(year) |>      summarise(n = n()) |>      pull(n) |>      unique(), \"\\n\") #> Monthly measurements per year: 12"},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"visualizing-seasonal-patterns","dir":"Articles","previous_headings":"Data exploration","what":"Visualizing seasonal patterns","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"Monthly SST patterns across years.","code":"ggplot(elnino_sst, aes(x = month, y = temperature, group = year, color = year)) +   geom_line(alpha = 0.7, linewidth = 0.8) +   scale_color_viridis_c(name = \"Year\") +   scale_x_continuous(breaks = 1:12, labels = month.abb) +   labs(     x = \"Month\",      y = \"Temperature (Â°C)\",     title = \"El NiÃ±o SST: Evolving seasonal patterns\",   )"},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"identifying-enso-events","dir":"Articles","previous_headings":"Data exploration","what":"Identifying ENSO events","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"Letâ€™s examine annual means identify major El NiÃ±o La NiÃ±a events: Annual mean SST anomalies highlighting major ENSO events. 1997-1998 2015-2016 El NiÃ±o events stand extreme warm phases.","code":"annual_means <- elnino_sst |>   index_by(year) |>   summarise(     mean_temp = mean(temperature),     .groups = \"drop\"   ) |>   mutate(     anomaly = mean_temp - mean(mean_temp),     phase = case_when(       anomaly > 0.5 ~ \"El NiÃ±o\",       anomaly < -0.5 ~ \"La NiÃ±a\",        TRUE ~ \"Neutral\"     )   )  ggplot(annual_means, aes(x = year, y = anomaly, fill = phase)) +   geom_col(alpha = 0.8) +   geom_hline(yintercept = c(-0.5, 0.5), linetype = \"dashed\", alpha = 0.5) +   scale_fill_manual(     values = c(\"El NiÃ±o\" = \"darkred\", \"La NiÃ±a\" = \"darkblue\", \"Neutral\" = \"gray60\"),     name = \"ENSO Phase\"   ) +   labs(     x = \"Year\",     y = \"Temperature anomaly (Â°C)\",     title = \"ENSO phases in the observational record\"   )"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"train-test-split-for-validation","dir":"Articles","previous_headings":"Modeling with cyclic splines","what":"Train-test split for validation","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"â€™ll use data 2014 training reserve 2015-2018 validationâ€”period includes major 2015-2016 El NiÃ±o:","code":"train_data <- elnino_sst |>    filter(year <= 2014) |>   arrange(year, month) test_data <- elnino_sst |>    filter(year > 2014) |>   arrange(year, month)"},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"the-functional-model-specification","dir":"Articles","previous_headings":"Modeling with cyclic splines","what":"The functional model specification","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"key innovation using cyclic cubic splines monthly pattern:","code":"mod_elnino <- ffc_gam(   temperature ~     # Time-varying intercept: captures inter-annual variability     fts(       year,        mean_only = TRUE,       time_k = 15     ) +          # Time-varying seasonal pattern: cyclic splines ensure continuity     fts(       month,        k = 12,        bs = \"cc\",        time_k = 15     ),   data = train_data,      # Specify cyclic boundaries for month   knots = list(month = c(0.5, 12.5)),   time = \"year\",   family = gaussian() )"},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"understanding-the-model-structure","dir":"Articles","previous_headings":"Modeling with cyclic splines","what":"Understanding the model structure","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"model decomposes SST : 1. Smooth inter-annual trend: fts(year, mean_only = TRUE) 2. Evolving seasonal cycle: fts(month, bs = \"cc\") cyclic boundaries cyclic spline ensures December flows smoothly January, critical seasonal forecasting.","code":"summary(mod_elnino) #>  #> Family: gaussian  #> Link function: identity  #>  #> Formula: #> temperature ~ s(year, by = fts_year1_mean, bs = \"ts\", k = 15,  #>     m = 2, id = 1) + s(year, by = fts_bs_s_month__1, bs = \"ts\",  #>     k = 15, m = 2, id = 2) + s(year, by = fts_bs_s_month__2,  #>     bs = \"ts\", k = 15, m = 2, id = 2) + s(year, by = fts_bs_s_month__3,  #>     bs = \"ts\", k = 15, m = 2, id = 2) + s(year, by = fts_bs_s_month__4,  #>     bs = \"ts\", k = 15, m = 2, id = 2) + s(year, by = fts_bs_s_month__5,  #>     bs = \"ts\", k = 15, m = 2, id = 2) + s(year, by = fts_bs_s_month__6,  #>     bs = \"ts\", k = 15, m = 2, id = 2) + s(year, by = fts_bs_s_month__7,  #>     bs = \"ts\", k = 15, m = 2, id = 2) + s(year, by = fts_bs_s_month__8,  #>     bs = \"ts\", k = 15, m = 2, id = 2) + s(year, by = fts_bs_s_month__9,  #>     bs = \"ts\", k = 15, m = 2, id = 2) + s(year, by = fts_bs_s_month__10,  #>     bs = \"ts\", k = 15, m = 2, id = 2) #>  #> Parametric coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept) 23.15273    0.05393   429.3   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Approximate significance of smooth terms: #>                               edf Ref.df      F  p-value     #> s(year):fts_year1_mean     13.597     14  7.663  < 2e-16 *** #> s(year):fts_bs_s_month__1   1.893     15  1.619 1.01e-06 *** #> s(year):fts_bs_s_month__2   2.013     15 16.873  < 2e-16 *** #> s(year):fts_bs_s_month__3   1.954     15  7.713  < 2e-16 *** #> s(year):fts_bs_s_month__4   2.005     15  2.699  < 2e-16 *** #> s(year):fts_bs_s_month__5   1.994     15  0.097   0.4697     #> s(year):fts_bs_s_month__6   1.994     15  3.880  < 2e-16 *** #> s(year):fts_bs_s_month__7   2.005     15 11.273  < 2e-16 *** #> s(year):fts_bs_s_month__8   1.954     15  7.704  < 2e-16 *** #> s(year):fts_bs_s_month__9   2.013     15  6.652  < 2e-16 *** #> s(year):fts_bs_s_month__10  1.893     15  0.495   0.0122 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> R-sq.(adj) =  0.804   Deviance explained =   82% #> GCV = 1.2609  Scale est. = 1.1516    n = 396"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"visualizing-fitted-seasonal-cycles","dir":"Articles","previous_headings":"Model diagnostics and interpretation","what":"Visualizing fitted seasonal cycles","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"can use plot_predictions() marginaleffects quick effortless effect plots outcome scale. example, plot shows modelâ€™s fitted seasonal shapes vary time: Fitted seasonal cycles selected years. model captures mean seasonal pattern year-specific deviations.","code":"plot_predictions(mod_elnino, condition = c(\"month\", \"year\")) +   labs(     x = \"Month\",     y = \"Temperature (Â°C)\",     title = \"Predicted training-period seasonal cycles\"   )"},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"extracting-time-varying-coefficients","dir":"Articles","previous_headings":"Model diagnostics and interpretation","what":"Extracting time-varying coefficients","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"functional coefficients reveal underlying dynamics model:","code":"# Extract coefficients with their time series structure func_coefs <- fts_coefs(mod_elnino, summary = FALSE, times = 10) print(func_coefs) #> # A tibble: 9,075 Ã— 6 #>    .basis         .parameter .time .estimate .realisation  year #>  * <chr>          <chr>      <int>     <dbl>        <int> <int> #>  1 fts_year1_mean location    1982    0.991             1  1982 #>  2 fts_year1_mean location    1983    0.415             1  1983 #>  3 fts_year1_mean location    1984    0.0490            1  1984 #>  4 fts_year1_mean location    1985   -0.0420            1  1985 #>  5 fts_year1_mean location    1986   -0.0395            1  1986 #>  6 fts_year1_mean location    1987   -0.198             1  1987 #>  7 fts_year1_mean location    1988   -0.528             1  1988 #>  8 fts_year1_mean location    1989   -0.701             1  1989 #>  9 fts_year1_mean location    1990   -0.398             1  1990 #> 10 fts_year1_mean location    1991    0.235             1  1991 #> # â„¹ 9,065 more rows  # Visualize coefficient evolution autoplot(func_coefs) +   labs(     title = \"Time-varying basis coefficients\",   )"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"exponential-smoothing-forecasts-of-functional-coefficients","dir":"Articles","previous_headings":"Forecasting ffc models","what":"Exponential Smoothing forecasts of functional coefficients","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"â€œETSâ€ model uses automatic exponential smoothing (Error, Trend, Seasonal) independently forecast basis function coefficient. ETS models particularly effective time series clear trends seasonal patterns, automatically selecting optimal combination error type (additive/multiplicative), trend (none/additive/damped), seasonal components. coefficient modeled separately, allowing method adapt unique temporal dynamics basis function. details exponential smoothing methods, see Hyndman & Athanasopoulos (2021).","code":"# Forecast coefficients using ETS coef_forecast <- forecast(   func_coefs,   h = 4,   times = 100,   model = \"ETS\" )  # Summarize forecasts for plotting forecast_summary <- coef_forecast |>   as_tibble() |>   group_by(.basis, year) |>   summarise(     mean = mean(.sim),     q05 = quantile(.sim, 0.05),     q10 = quantile(.sim, 0.10),     q90 = quantile(.sim, 0.90),     q95 = quantile(.sim, 0.95),     .groups = \"drop\"   )  # Add historical values for context historical_summary <- func_coefs |>   as_tibble() |>   group_by(.basis, year) |>   summarise(     mean = mean(.estimate),     q05 = quantile(.estimate, 0.05),     q10 = quantile(.estimate, 0.10),     q90 = quantile(.estimate, 0.90),     q95 = quantile(.estimate, 0.95),     .groups = \"drop\"   )  # Plot with ribbons for each basis function ggplot(forecast_summary, aes(x = year)) +   geom_ribbon(aes(ymin = q05, ymax = q95, fill = .basis), alpha = 0.2) +   geom_ribbon(aes(ymin = q10, ymax = q90, fill = .basis), alpha = 0.3) +   geom_line(aes(y = mean, color = .basis), linewidth = 1) +   geom_ribbon(data = historical_summary,               aes(ymin = q05, ymax = q95, fill = .basis), alpha = 0.2) +   geom_ribbon(data = historical_summary,               aes(ymin = q10, ymax = q90, fill = .basis), alpha = 0.3) +   geom_line(data = historical_summary,             aes(y = mean, color = .basis), linewidth = 1) +   geom_vline(xintercept = 2014.5, linetype = \"dashed\", alpha = 0.5) +   facet_wrap(~.basis, scales = \"free_y\", ncol = 2) +   scale_fill_viridis_d(guide = \"none\") +   scale_color_viridis_d(guide = \"none\") +   labs(     x = \"Year\",     y = \"Coefficient value\",     title = \"Forecasted functional basis coefficients\",   )"},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"generating-temperature-forecasts-with-gpdf","dir":"Articles","previous_headings":"Forecasting ffc models","what":"Generating temperature forecasts with GPDF","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"Transform coefficient forecasts back temperature predictions using Gaussian Process Dynamic Factor (GPDF) models. GPDF approach models evolution multiple time series lower-dimensional set latent factors, following Gaussian process. captures complex dependencies different basis coefficients providing principled uncertainty quantification. model estimates K latent factors drive dynamics coefficients jointly, leading coherent forecasts independent modeling. Gaussian process priors factors allow flexible non-linear dynamics maintaining smoothness. theoretical background Gaussian processes, see Michael Betancourtâ€™s case study. Forecasted seasonal cycles 2015-2018 uncertainty bands.","code":"# Create forecast data grid forecast_grid <- expand.grid(   month = 1:12,   year = 2015:2018 ) |>   as_tibble() |>   as_tsibble(index = year, key = month) |>   arrange(year, month)  # Generate temperature forecasts temp_forecasts <- forecast(   mod_elnino,   newdata = forecast_grid,   model = \"GPDF\",   mean_model = \"ETS\",   K = 3,   type = \"response\",   chains = 1 )  # Combine with actual test data for comparison forecast_results <- temp_forecasts |>   bind_cols(forecast_grid) |>   left_join(     test_data |> select(year, month, actual = temperature),     by = c(\"year\", \"month\")   )  # Plot forecasts vs actuals ggplot(forecast_results, aes(x = month)) +   geom_ribbon(aes(ymin = .q2.5, ymax = .q97.5), alpha = 0.2, fill = \"darkred\") +   geom_ribbon(aes(ymin = .q10, ymax = .q90), alpha = 0.3, fill = \"darkred\") +   geom_line(aes(y = .estimate), color = \"darkred\", linewidth = 1) +   geom_line(aes(y = actual), color = \"black\", linewidth = 1.2) +   geom_point(aes(y = actual), color = \"black\", size = 1.5) +   facet_wrap(~year, ncol = 2) +   scale_x_continuous(breaks = 1:12, labels = month.abb) +   labs(     x = \"Month\",     y = \"Temperature (C)\",     title = \"Forecast validation: 2015-2018\",     subtitle = \"Red: forecast (with 80% and 95% PIs), Black: observed\"   )"},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"spectral-validation","dir":"Articles","previous_headings":"","what":"Spectral validation","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"can also check model preserves spectral characteristics original data. Spectral analysis decomposes time series frequency components, revealing periodic patterns strengths. El NiÃ±o data, expect see dominant annual cycles (frequency = 1) potentially sub-annual harmonics. good forecast preserve fundamental frequency characteristics, ensuring predicted seasonal patterns maintain spectral signature observed data. validation particularly important functional forecasting want ensure cyclical nature data maintained across forecast horizon. Spectral density comparison uncertainties. forecast preserves key frequency components quantified uncertainty bands.","code":"# Spectral analysis with uncertainty quantification library(stats)  # Calculate spectrum for observed data actual_ts <- ts(forecast_results$actual, frequency = 12) actual_spec <- spectrum(actual_ts, plot = FALSE)  # Calculate spectra for forecast ensemble (using quantiles) forecast_spectra <- list() quantiles <- c(0.05, 0.10, 0.50, 0.90, 0.95)  for (q in quantiles) {   forecast_q <- forecast_results[[paste0(\".q\", sprintf(\"%.0f\", q * 100))]]   if (is.null(forecast_q)) {     # Handle different quantile naming conventions     if (q == 0.05) forecast_q <- forecast_results$.q2.5     else if (q == 0.95) forecast_q <- forecast_results$.q97.5     else if (q == 0.50) forecast_q <- forecast_results$.estimate     else next   }      forecast_ts_q <- ts(forecast_q, frequency = 12)   forecast_spec_q <- spectrum(forecast_ts_q, plot = FALSE)      forecast_spectra[[paste0(\"q\", sprintf(\"%.0f\", q * 100))]] <- data.frame(     frequency = forecast_spec_q$freq,     power = forecast_spec_q$spec,     quantile = q   ) }  # Combine spectral estimates forecast_spec_df <- do.call(rbind, forecast_spectra)  # Calculate summary statistics across quantiles for each frequency forecast_summary <- forecast_spec_df |>   group_by(frequency) |>   summarise(     median = median(power),     q05 = quantile(power, 0.05, na.rm = TRUE),     q10 = quantile(power, 0.10, na.rm = TRUE),      q90 = quantile(power, 0.90, na.rm = TRUE),     q95 = quantile(power, 0.95, na.rm = TRUE),     .groups = \"drop\"   )  # Observed spectrum data observed_df <- data.frame(   frequency = actual_spec$freq,   power = actual_spec$spec )  # Create plot with uncertainty bands ggplot() +   # Forecast uncertainty bands   geom_ribbon(     data = forecast_summary,     aes(x = frequency, ymin = log(q05), ymax = log(q95)),     alpha = 0.2, fill = \"darkred\"   ) +   geom_ribbon(     data = forecast_summary,      aes(x = frequency, ymin = log(q10), ymax = log(q90)),     alpha = 0.3, fill = \"darkred\"   ) +   # Forecast median   geom_line(     data = forecast_summary,     aes(x = frequency, y = log(median)),     color = \"darkred\", linewidth = 1.2   ) +   # Observed spectrum   geom_line(     data = observed_df,     aes(x = frequency, y = log(power)),     color = \"black\", linewidth = 1.2   ) +   # Highlight annual frequency   geom_vline(xintercept = 1, linetype = \"dashed\", alpha = 0.6) +   annotate(\"text\", x = 1.1, y = max(log(observed_df$power)) * 0.9,             label = \"Annual cycle\", hjust = 0, size = 3) +   labs(     x = \"Frequency (cycles per year)\",     y = \"Log spectral density\",     title = \"Spectral validation with forecast uncertainty\",     subtitle = \"Black: observed, Red: forecast median with 80% and 90% bands\"   ) +   theme(legend.position = \"none\")"},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"integration-with-fable-ecosystem","dir":"Articles","previous_headings":"","what":"Integration with fable ecosystem","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"ffc package provides seamless integration fable ecosystem as_fable() function. allows ffc forecasts converted fable objects, enabling use fableâ€™s accuracy metrics visualization tools: El NiÃ±o SST forecasts using ensemble model fable integration. Red ribbons show prediction intervals, black lines show observed values. integration provides access fableâ€™s comprehensive suite forecast evaluation tools maintaining flexibility power functional forecasting methods.","code":"# Convert ffc forecasts to fable format fable_forecasts <- as_fable(   mod_elnino,   newdata = test_data,   model = \"ENS\",   mean_model = \"ETS\",   type = \"response\",   chains = 1 )  # Evaluate forecast accuracy using fable metrics accuracy(fable_forecasts, test_data) #> # A tibble: 12 Ã— 11 #>    .model  month .type    ME  RMSE   MAE   MPE  MAPE  MASE RMSSE    ACF1 #>    <chr>   <int> <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl> #>  1 FFC_ENS     1 Test  0.542 1.10  0.943 2.03   3.72   NaN   NaN -0.236  #>  2 FFC_ENS     2 Test  0.132 1.00  0.898 0.373  3.37   NaN   NaN -0.310  #>  3 FFC_ENS     3 Test  0.488 1.13  0.926 1.66   3.36   NaN   NaN -0.408  #>  4 FFC_ENS     4 Test  0.252 0.865 0.749 0.861  2.88   NaN   NaN -0.406  #>  5 FFC_ENS     5 Test  0.541 1.23  0.923 1.98   3.59   NaN   NaN -0.201  #>  6 FFC_ENS     6 Test  0.261 1.15  0.841 0.881  3.47   NaN   NaN  0.0770 #>  7 FFC_ENS     7 Test  0.560 1.32  0.840 2.23   3.54   NaN   NaN  0.0548 #>  8 FFC_ENS     8 Test  0.432 1.13  0.838 1.81   3.82   NaN   NaN  0.140  #>  9 FFC_ENS     9 Test  0.714 1.40  0.983 3.10   4.47   NaN   NaN  0.0984 #> 10 FFC_ENS    10 Test  0.585 1.47  1.14  2.36   5.19   NaN   NaN  0.0282 #> 11 FFC_ENS    11 Test  0.630 1.39  1.10  2.56   4.85   NaN   NaN -0.0418 #> 12 FFC_ENS    12 Test  0.845 1.51  1.37  3.33   5.76   NaN   NaN -0.0638  # Create publication-ready plots using fable's autoplot fable_forecasts |>   autoplot(data = train_data, show_gap = FALSE, fill = \"darkred\") +   labs(     x = \"Year\",     y = \"Temperature (C)\",     title = \"Forecasts broken down by month\"   )"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"when-to-use-cyclic-splines","dir":"Articles","previous_headings":"Key insights and best practices","what":"When to use cyclic splines","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"Cyclic splines essential : - Data natural periodicity (seasonal, diurnal, etc.) - Boundary continuity matters interpretation - Forecasting requires smooth transitions across periods Key implementation tips: - Set knots just outside data range: c(0.5, 12.5) months 1-12 - Choose k (basis dimension) based expected complexity - Use bs = \"cc\" cyclic cubic regression splines detailed guidance modeling seasonal data GAMs, see Simpson (2014).","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"gpdf-model-advantages","dir":"Articles","previous_headings":"Key insights and best practices","what":"GPDF model advantages","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"Gaussian Process Dynamic Factor approach excels : - Multiple related time series need joint forecasting - Dimension reduction helps identify shared patterns - Uncertainty quantification critical - Non-linear dynamics present","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"vignette demonstrated advanced functional forecasting techniques using El NiÃ±o SST data: Cyclic splines naturally handle seasonal patterns boundary continuity Time-varying coefficients* capture evolving relationships GPDF models provide sophisticated multivariate forecasting Comprehensive validation ensures reliable predictions ffc package integrates methods unified framework, enabling: - Flexible specification functional relationships - State---art time series forecasting coefficients - Proper uncertainty quantification throughout - Seamless integration tidyverse fable ecosystems","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/elnino-forecasting.html","id":"further-reading","dir":"Articles","previous_headings":"Conclusion","what":"Further reading","title":"Forecasting El NiÃ±o Patterns with Cyclic Splines and Dynamic Factor Models","text":"Hyndman & Athanasopoulos (2021): Forecasting: Principles Practice Wood (2017): Generalized Additive Models: Introduction R Ramsay & Silverman (2005): Functional Data Analysis NOAA Climate Prediction Center: ENSO diagnostics forecasting","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Modeling Mortality Trends with Functional Forecasting","text":"Mortality patterns represent one fundamental demographic processes, yet traditional statistical approaches often miss complex, evolving functional relationships age death rates time. vignette demonstrates functional forecasting using ffc package captures dynamic relationships change shapeâ€”just magnitudeâ€”time.","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"what-makes-mortality-data-ideal-for-functional-forecasting","dir":"Articles","previous_headings":"Introduction","what":"What makes mortality data ideal for functional forecasting?","title":"Modeling Mortality Trends with Functional Forecasting","text":"Complex age patterns: Mortality exhibits characteristic J-shaped curves across age groups Temporal evolution: functional relationships shift systematically time Smooth transitions: Changes occur gradually, making suitable GAM-based smoothing Forecasting relevance: Understanding future mortality trends critical policy implications","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"key-concepts-well-explore","dir":"Articles","previous_headings":"Introduction","what":"Key concepts weâ€™ll explore","title":"Modeling Mortality Trends with Functional Forecasting","text":"Time-varying coefficients: functional relationships evolve time Hierarchical smoothing: Modeling shared trends group-specific deviations Functional forecasting: Predicting entire curves future Model diagnostics: Validating functional time series models","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"data-exploration","dir":"Articles","previous_headings":"","what":"Data exploration","title":"Modeling Mortality Trends with Functional Forecasting","text":"â€™ll use Queensland mortality data spanning 1980-2020, containing death counts age, sex, year corresponding population denominators. dataset structure ideal functional analysis: functional predictor (age) whose relationship outcome (mortality) changes time (year), hierarchical structure (sex).","code":"data(\"qld_mortality\") head(qld_mortality, 15) #> # A tsibble: 15 x 5 [1Y] #> # Key:       age, sex [1] #>     year   age sex    deaths population #>    <int> <int> <fct>   <dbl>      <dbl> #>  1  1980     0 female    190     17700. #>  2  1981     0 female    175     18785. #>  3  1982     0 female    190     19698. #>  4  1983     0 female    165     19908. #>  5  1984     0 female    148     19573. #>  6  1985     0 female    164     19458. #>  7  1986     0 female    147     19405. #>  8  1987     0 female    159     19421. #>  9  1988     0 female    153     19841. #> 10  1989     0 female    184     20942. #> 11  1990     0 female    155     21841. #> 12  1991     0 female    143     22187. #> 13  1992     0 female    154     22314. #> 14  1993     0 female    149     22581. #> 15  1994     0 female    109     22859."},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"visualizing-mortality-patterns","dir":"Articles","previous_headings":"Data exploration","what":"Visualizing mortality patterns","title":"Modeling Mortality Trends with Functional Forecasting","text":"Observed mortality rates age Queensland, 1980-2020. characteristic J-shaped curves show systematic downward shifts time, indicating mortality improvements across age groups. Key observations: J-shaped curves: High infant mortality, low childhood mortality, exponential increase age Temporal shifts: Consistent downward movement entire curves time Sex differences: Males consistently higher mortality, similar temporal patterns Functional evolution: shape evolves, just vertical shifts Overall decline: Mortality rates declined substantially across ages, reflecting major improvements healthcare, lifestyle, living conditions","code":"ggplot(   data = qld_mortality,   aes(     x = age,     y = deaths / population,     group = year,     colour = year   ) ) +   geom_line(alpha = 0.7) +   facet_wrap(~sex) +   scale_colour_viridis_c(name = \"Year\") +   labs(     x = \"Age\",      y = \"Mortality rate\",     title = \"Queensland mortality patterns over time\"   ) +   scale_y_log10()"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"why-traditional-models-fall-short","dir":"Articles","previous_headings":"Functional modeling approach","what":"Why traditional models fall short","title":"Modeling Mortality Trends with Functional Forecasting","text":"Standard approaches might model : assumes linear age effects additive time trendsâ€”clearly inadequate evolving functional relationships.","code":"# Traditional approach - misses functional evolution glm(deaths ~ age + year + sex, family = poisson(), offset = log(population))"},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"the-ffc-solution-time-varying-coefficients","dir":"Articles","previous_headings":"Functional modeling approach","what":"The ffc solution: time-varying coefficients","title":"Modeling Mortality Trends with Functional Forecasting","text":"fts() function creates basis functions whose coefficients evolve time, capturing age-mortality relationship changes:","code":"mod <- ffc_gam(   deaths ~     offset(log(population)) +     sex +     age +     # Time-varying level: shared temporal trends     fts(       year,       mean_only = TRUE,       bs = \"tp\",       time_k = 35,       time_m = 1     ) +     # Time-varying age effects: sex-specific deviations     fts(       age,       by = sex,       bs = \"tp\",        time_k = 15,       time_m = 1     ),   time = \"year\",   data = qld_mortality,   family = poisson(),   # Efficient for large datasets   engine = \"bam\" )"},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"understanding-the-model-structure","dir":"Articles","previous_headings":"Functional modeling approach","what":"Understanding the model structure","title":"Modeling Mortality Trends with Functional Forecasting","text":"Key components: Fixed effects: sex captures baseline male-female differences, age captures baseline mortality rates per age Time-varying level: fts(year, mean_only = TRUE) models shared temporal trends Time-varying functions: fts(age, = sex) captures age patterns evolve differently sex model automatically creates hierarchical structure basis functions become variables smooths time, sharing smoothing parameters computational efficiency.","code":"summary(mod) #>  #> Family: poisson  #> Link function: log  #>  #> Formula: #> deaths ~ sex + age + offset(log(population)) + s(year, by = fts_year1_mean,  #>     bs = \"ts\", k = 35, m = 1, id = 1) + s(year, by = fts_bs_s_age_bysexfemale_1,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexfemale_2,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexfemale_3,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexfemale_4,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexfemale_5,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexfemale_6,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexfemale_7,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexfemale_8,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexfemale_9,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexmale_1,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexmale_2,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexmale_3,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexmale_4,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexmale_5,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexmale_6,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexmale_7,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexmale_8,  #>     bs = \"ts\", k = 15, m = 1, id = 2) + s(year, by = fts_bs_s_age_bysexmale_9,  #>     bs = \"ts\", k = 15, m = 1, id = 2) #>  #> Parametric coefficients: #>              Estimate Std. Error z value Pr(>|z|)     #> (Intercept)  3.371181   2.488125   1.355 0.175447     #> sexmale      0.574306   0.004986 115.189  < 2e-16 *** #> age         -0.180386   0.049764  -3.625 0.000289 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Approximate significance of smooth terms: #>                                       edf Ref.df   Chi.sq p-value     #> s(year):fts_year1_mean             32.048     34 10329.34  <2e-16 *** #> s(year):fts_bs_s_age_bysexfemale_1 14.470     15 11934.09  <2e-16 *** #> s(year):fts_bs_s_age_bysexfemale_2 12.621     15  9711.83  <2e-16 *** #> s(year):fts_bs_s_age_bysexfemale_3 14.477     15    68.77  <2e-16 *** #> s(year):fts_bs_s_age_bysexfemale_4 13.307     15  7609.29  <2e-16 *** #> s(year):fts_bs_s_age_bysexfemale_5 14.505     15   498.50  <2e-16 *** #> s(year):fts_bs_s_age_bysexfemale_6 13.147     15  7787.91  <2e-16 *** #> s(year):fts_bs_s_age_bysexfemale_7 14.265     15   712.25  <2e-16 *** #> s(year):fts_bs_s_age_bysexfemale_8  9.615     15 11101.16  <2e-16 *** #> s(year):fts_bs_s_age_bysexfemale_9 11.815     15    39.30  <2e-16 *** #> s(year):fts_bs_s_age_bysexmale_1   14.347     15  7385.09  <2e-16 *** #> s(year):fts_bs_s_age_bysexmale_2   12.758     15  9625.52  <2e-16 *** #> s(year):fts_bs_s_age_bysexmale_3   14.606     15   106.51  <2e-16 *** #> s(year):fts_bs_s_age_bysexmale_4   13.620     15  9829.84  <2e-16 *** #> s(year):fts_bs_s_age_bysexmale_5   14.601     15  1741.23  <2e-16 *** #> s(year):fts_bs_s_age_bysexmale_6   13.601     15  9939.09  <2e-16 *** #> s(year):fts_bs_s_age_bysexmale_7   14.438     15   308.23  <2e-16 *** #> s(year):fts_bs_s_age_bysexmale_8    9.738     15 12228.38  <2e-16 *** #> s(year):fts_bs_s_age_bysexmale_9   11.218     15    72.68  <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> R-sq.(adj) =  0.986   Deviance explained = 97.6% #> fREML =  22150  Scale est. = 1         n = 8282"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"predicted-functional-curves","dir":"Articles","previous_headings":"Model interpretation","what":"Predicted functional curves","title":"Modeling Mortality Trends with Functional Forecasting","text":"Model predictions showing expected mortality curves age year. Smooth curves demonstrate systematic evolution age-mortality relationship four decades. model successfully captures smooth evolution J-shaped mortality curves preserving characteristic functional form. downward trend across mortality curves demonstrates substantial improvement survival rates 40-year period. reflects major advances healthcare, improved living conditions, better nutrition, reduced exposure environmental hazards. Notably, decline uniform across ages - model captures rate improvement varies age group sex, periods showing rapid mortality decline others.","code":"newdat <- qld_mortality newdat$population <- 1  # Standardized predictions  newdat$preds <- predict(   mod,   newdata = newdat,   type = \"response\" )  ggplot(   data = newdat,   aes(     x = age,     y = preds,     group = year,     colour = year   ) ) +   geom_line() +   facet_wrap(~sex) +   scale_colour_viridis_c(name = \"Year\") +   labs(     x = \"Age\",     y = \"Expected mortality rate\",     title = \"Model predictions: evolving mortality patterns\"   ) +   scale_y_log10()"},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"focused-analysis-teenage-mortality-trends","dir":"Articles","previous_headings":"Model interpretation","what":"Focused analysis: teenage mortality trends","title":"Modeling Mortality Trends with Functional Forecasting","text":"Letâ€™s examine mortality patterns changed specific age group leveraging power marginaleffects: Predicted mortality trends 17-year-olds Queensland, 1980-2020. Shows approximately 70% decline mortality rates consistent male-female differences.","code":"plot_predictions(   mod,   by = c(\"year\", \"sex\"),   newdata = datagrid(     age = 17,     year = unique,     sex = unique,     population = 1   ),   type = \"response\" ) +   labs(     x = \"Year\",     y = \"Expected mortality rate\",     title = \"Teenage mortality trends over time\"   ) +   scale_y_log10()"},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"rate-of-change-analysis","dir":"Articles","previous_headings":"Model interpretation","what":"Rate of change analysis","title":"Modeling Mortality Trends with Functional Forecasting","text":"can look deeper predictions understand fast mortality improving, using marginaleffects support: First derivatives showing rate mortality improvement 17-year-olds. Fluctuations reveal periods faster slower mortality decline.","code":"plot_slopes(   mod,   variables = \"year\",   by = c(\"year\", \"sex\"),   newdata = datagrid(     age = 17,     year = unique,     sex = unique,     population = 1   ),   type = \"response\" ) +   labs(     x = \"Year\",     y = \"Rate of mortality change\",     title = \"Speed of mortality improvement over time\"   ) +   geom_hline(     yintercept = 0,     linetype = \"dashed\",     alpha = 0.7   )"},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"extracting-time-varying-coefficients","dir":"Articles","previous_headings":"","what":"Extracting time-varying coefficients","title":"Modeling Mortality Trends with Functional Forecasting","text":"power functional forecasting lies treating evolving coefficients time series can forecasted:","code":"functional_coefs <- fts_coefs(   mod,   summary = FALSE,   times = 10 ) functional_coefs #> # A tibble: 19,475 Ã— 6 #>    .basis         .parameter .time .estimate .realisation  year #>  * <chr>          <chr>      <int>     <dbl>        <int> <int> #>  1 fts_year1_mean location    1980     0.356            1  1980 #>  2 fts_year1_mean location    1981     0.368            1  1981 #>  3 fts_year1_mean location    1982     0.403            1  1982 #>  4 fts_year1_mean location    1983     0.319            1  1983 #>  5 fts_year1_mean location    1984     0.324            1  1984 #>  6 fts_year1_mean location    1985     0.318            1  1985 #>  7 fts_year1_mean location    1986     0.259            1  1986 #>  8 fts_year1_mean location    1987     0.247            1  1987 #>  9 fts_year1_mean location    1988     0.234            1  1988 #> 10 fts_year1_mean location    1989     0.265            1  1989 #> # â„¹ 19,465 more rows"},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"visualizing-coefficient-evolution","dir":"Articles","previous_headings":"Extracting time-varying coefficients","what":"Visualizing coefficient evolution","title":"Modeling Mortality Trends with Functional Forecasting","text":"Time series functional basis coefficients. panel shows different aspects age-mortality relationship evolved time, revealing complex temporal dependencies. Interpretation: Complex patterns: coefficient series shows distinct temporal behavior Smooth evolution: Changes occur gradually, suitable time series modeling Interdependence: Multiple coefficients work together create functional evolution","code":"autoplot(functional_coefs) +   labs(title = \"Evolution of functional basis coefficients\")"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"coefficient-forecasting","dir":"Articles","previous_headings":"Forecasting mortality patterns","what":"Coefficient forecasting","title":"Modeling Mortality Trends with Functional Forecasting","text":"forecast includes uncertainty time series models original coefficient estimation, providing realistic prediction intervals.","code":"functional_fc <- forecast(   object = functional_coefs,   h = 5,      # 5-year horizon   times = 10, # Forecast replicates   model = \"ARIMA\" ) functional_fc #> # A tsibble: 59,375 x 6 [1Y] #> # Key:       .basis, .realisation, .model, .rep [11,875] #>    .basis                     .realisation .model  year .rep   .sim #>    <chr>                             <int> <chr>  <dbl> <chr> <dbl> #>  1 fts_bs_s_age_bysexfemale_1            1 ARIMA   2021 1      1.96 #>  2 fts_bs_s_age_bysexfemale_1            1 ARIMA   2022 1      1.92 #>  3 fts_bs_s_age_bysexfemale_1            1 ARIMA   2023 1      1.86 #>  4 fts_bs_s_age_bysexfemale_1            1 ARIMA   2024 1      1.81 #>  5 fts_bs_s_age_bysexfemale_1            1 ARIMA   2025 1      1.78 #>  6 fts_bs_s_age_bysexfemale_1            1 ARIMA   2021 10     1.96 #>  7 fts_bs_s_age_bysexfemale_1            1 ARIMA   2022 10     1.93 #>  8 fts_bs_s_age_bysexfemale_1            1 ARIMA   2023 10     1.88 #>  9 fts_bs_s_age_bysexfemale_1            1 ARIMA   2024 10     1.86 #> 10 fts_bs_s_age_bysexfemale_1            1 ARIMA   2025 10     1.86 #> # â„¹ 59,365 more rows"},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"future-mortality-patterns","dir":"Articles","previous_headings":"Forecasting mortality patterns","what":"Future mortality patterns","title":"Modeling Mortality Trends with Functional Forecasting","text":"Letâ€™s demonstrate generate complete mortality curve forecasts combining forecasted coefficients model structure. use ensemble model (â€œENSâ€) forecast time-varying mean, tends give robust forecasts mdoels : Forecasted mortality curves Queensland, 2021-2025. Shows functional forecasting approach predicts future age-mortality patterns. forecasting approach enables prediction entire functional relationships combining time series forecasts functional coefficients underlying model structure. easily convert fable object (using as_fable()) compare holdout data compute forecast scores supported fable.","code":"# Create forecast data for future years future_years <- 2021:2025 newdata_forecast <- expand.grid(   age = unique(qld_mortality$age),   sex = unique(qld_mortality$sex),   year = future_years,   population = 1 )  # Generate forecasted mortality curves using forecast() # This integrates the time series forecasts of coefficients mortality_forecasts <- forecast(   object = mod,   newdata = newdata_forecast,   model = \"ARIMA\",   mean_model = \"ENS\",   type = \"expected\" ) head(mortality_forecasts) #> # A tibble: 6 Ã— 6 #>   .estimate  .error    .q2.5     .q10     .q90   .q97.5 #>       <dbl>   <dbl>    <dbl>    <dbl>    <dbl>    <dbl> #> 1  0.00167  0.00161 0.00107  0.00130  0.00236  0.00318  #> 2  0.00105  0.00109 0.000683 0.000776 0.00125  0.00204  #> 3  0.000665 0.00142 0.000431 0.000512 0.000788 0.00104  #> 4  0.000446 0.00226 0.000285 0.000358 0.000558 0.000747 #> 5  0.000285 0.00232 0.000190 0.000216 0.000360 0.000428 #> 6  0.000194 0.00141 0.000113 0.000144 0.000241 0.000330  # Plot forecasted mortality rates, together with uncertainties ggplot(mortality_forecasts |>          dplyr::bind_cols(newdata_forecast),        aes(x = age,            y = .estimate,            group = year,            colour = year)) +   geom_ribbon(aes(     ymin = .q10,     ymax = .q90,     fill = year   ),   alpha = 0.2,   colour = NA) +   geom_line() +   facet_wrap(~sex) +   scale_colour_viridis_c(name = \"Year\") +   scale_fill_viridis_c(name = \"Year\") +   labs(     x = \"Age\",      y = \"Mortality rate\",     title = \"Expected mortality\"   ) +   scale_y_log10()"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"what-we-learned-about-queensland-mortality","dir":"Articles","previous_headings":"Key insights and methodology","what":"What we learned about Queensland mortality","title":"Modeling Mortality Trends with Functional Forecasting","text":"Systematic improvement: Mortality declined across age groups 40 years Functional evolution: Changes involved curve shape, just magnitude shifts Heterogeneous trends: Rate improvement varied age sex Complex patterns: Simple parametric models miss relationships","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"why-functional-forecasting-matters","dir":"Articles","previous_headings":"Key insights and methodology","what":"Why functional forecasting matters","title":"Modeling Mortality Trends with Functional Forecasting","text":"Captures complexity: Models evolving functional relationships traditional methods miss Preserves structure: Maintains biological/physical constraints forecasts Quantifies uncertainty: Propagates uncertainty entire functional evolution Policy relevance: Enables sophisticated demographic projections","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"model-design-principles","dir":"Articles","previous_headings":"Key insights and methodology","what":"Model design principles","title":"Modeling Mortality Trends with Functional Forecasting","text":"Hierarchical structure: Shared trends group-specific deviations Temporal smoothing: Balance flexibility smoothness using time_k time_m Basis choice: Thin plate splines work well age time Computational efficiency: bam() engine handles large datasets effectively","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"advanced-features","dir":"Articles","previous_headings":"Extensions and further analysis","what":"Advanced features","title":"Modeling Mortality Trends with Functional Forecasting","text":"ffc package supports additional complexity: - Multiple functional predictors: fts(age) + fts(time_since_event) - Interaction effects: Functional relationships depend variables - Alternative distributions: Beyond Poisson handle different data types","code":""},{"path":"https://nicholasjclark.github.io/ffc/articles/mortality-analysis.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Modeling Mortality Trends with Functional Forecasting","text":"Functional forecasting ffc provides principled approach modeling predicting evolving functional relationships. treating time-varying coefficients forecastable time series, can: Capture complexity traditional methods miss Generate realistic forecasts entire functional relationships Quantify uncertainty appropriately across sources Provide actionable insights policy planning Queensland mortality analysis demonstrates capabilities real-world context, revealing patterns trends inform understanding demographic change enable sophisticated projection methods public health planning.","code":""},{"path":"https://nicholasjclark.github.io/ffc/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nicholas J Clark. Author, maintainer. KANK Karunarathna. Contributor.","code":""},{"path":"https://nicholasjclark.github.io/ffc/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Clark N (2025). ffc: Functional ForeCasting. R package version 0.0.0.9000, https://nicholasjclark.github.io/ffc.","code":"@Manual{,   title = {ffc: Functional ForeCasting},   author = {Nicholas J Clark},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://nicholasjclark.github.io/ffc}, }"},{"path":"https://nicholasjclark.github.io/ffc/index.html","id":"ffc","dir":"","previous_headings":"","what":"ffc â€¢ Functional ForeCasting","title":"ffc â€¢ Functional ForeCasting","text":"Functional ForeCasting  goal ffc ðŸ“¦ forecast complex, time-changing functional relationships integrating Generalized Additive Models dynamic factor functional basis expansions. Key benefits: Model functional responses change shape time (just magnitude) Forecast entire curves future, just single values Handle complex multivariate time series functional structure Seamless integration powerful mgcv fable ecosystems package introduces dynamic functional predictors using new fts() term, decomposes functional time series time-varying basis coefficients can forecasted using either independent time series models fable package efficient dynamic factor models using precompiled Stan models.","code":""},{"path":"https://nicholasjclark.github.io/ffc/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"ffc â€¢ Functional ForeCasting","text":"can install development version ffc GitHub :","code":"# install.packages(\"pak\") pak::pak(\"nicholasjclark/ffc\")"},{"path":"https://nicholasjclark.github.io/ffc/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"ffc â€¢ Functional ForeCasting","text":"","code":"library(ffc)  # Fit a model with time-varying coefficients mod <- ffc_gam(   response ~ fts(predictor, time_k = 10),     data = your_data,   time = \"time_column\",   family = gaussian() )  # Forecast the functional coefficients fc <- forecast(mod, newdata = future_data, model = \"ARDF\")"},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/index.html","id":"tourism-forecasting-with-fabletools-integration","dir":"","previous_headings":"Examples","what":"Tourism Forecasting with fabletools Integration","title":"ffc â€¢ Functional ForeCasting","text":"aim forecast number domestic visitors Melbourne, Australia. data can found tsibble::tourism data set. now need explicitly add quarter time variables data, future done automatically seamless integration tsibbleverse Split training testing folds. wil aim forecast last 5 quarters data Now fit ffc_gam. use time-varying level time-varying seasonality components, together Tweedie observation model (outcome, Trips, consists non-negative real values). model simpler use 'gam' engine fitting: autoplot() method handy viewing time-varying basis coefficients ffc_gam() models. draw 10 realisations estimated coefficient distributions plot .  can also draw time-varying basis coefficients using support gratia package, helpful functions plotting smooth effects:  plots show time-varying coefficients set basis functions. one function representing mean series (essentially constant) well three basis functions representing quarterly seasonality. coefficient can change time, allowing entire functional series change shape time. can compute forecast distribution fitting basis coefficient forecast models parallel (automatically supported within fable package). fit independent exponential smoothing models coefficient time series can also convert resulting forecasts fable object automatic plotting /scoring forecasts Leverage fabletools ecosystem forecast analysis Next can explore compare forecasts ffc models traditional time series models leveraging simplicity power fable ecosystem  plots illustrate ffc models outperform traditional forecasting models forecasting experiment thinking functional time series problem.","code":"library(fable) library(tsibble) library(tidyverse) library(ggplot2); theme_set(theme_bw(base_size = 12)) tourism_melb <- tourism |>   filter(     Region == \"Melbourne\",     Purpose == \"Visiting\"   ) |>   mutate(     quarter = lubridate::quarter(Quarter),     time = dplyr::row_number()   ) tourism_melb #> # A tsibble: 80 x 7 [1Q] #> # Key:       Region, State, Purpose [1] #>    Quarter Region    State    Purpose  Trips quarter  time #>      <qtr> <chr>     <chr>    <chr>    <dbl>   <int> <int> #>  1 1998 Q1 Melbourne Victoria Visiting  666.       1     1 #>  2 1998 Q2 Melbourne Victoria Visiting  601.       2     2 #>  3 1998 Q3 Melbourne Victoria Visiting  529.       3     3 #>  4 1998 Q4 Melbourne Victoria Visiting  575.       4     4 #>  5 1999 Q1 Melbourne Victoria Visiting  623.       1     5 #>  6 1999 Q2 Melbourne Victoria Visiting  530.       2     6 #>  7 1999 Q3 Melbourne Victoria Visiting  479.       3     7 #>  8 1999 Q4 Melbourne Victoria Visiting  538.       4     8 #>  9 2000 Q1 Melbourne Victoria Visiting  618.       1     9 #> 10 2000 Q2 Melbourne Victoria Visiting  549.       2    10 #> # â„¹ 70 more rows train <- tourism_melb |>   dplyr::slice_head(n = 75)  test <- tourism_melb |>   dplyr::slice_tail(n = 5) mod <- ffc_gam(   Trips ~     # Use mean_only = TRUE to model a time-varying mean     fts(       time,       mean_only = TRUE,       time_k = 50,       time_m = 1     ) +     # Time-varying seasonality     fts(       quarter,       k = 4,       time_k = 15,       time_m = 1     ),   time = \"time\",   data = train,   family = tw(),   engine = \"gam\" ) fts_coefs(mod, times = 10, summary = FALSE) |>   autoplot() gratia::draw(mod) fc <- forecast(   object = mod,   newdata = test,   model = \"ETS\",   summary = FALSE ) # Using the new as_fable method for seamless conversion fc_ffc <- as_fable(mod, newdata = test, forecasts = fc) fc_ffc #> # A fable: 5 x 10 [1Q] #> # Key:     Region, State, Purpose [1] #>   Quarter Region    State   Purpose Trips quarter  time       .dist .mean .model #>     <qtr> <chr>     <chr>   <chr>   <dbl>   <int> <int>      <dist> <dbl> <chr>  #> 1 2016 Q4 Melbourne Victorâ€¦ Visitiâ€¦  804.       4    76 sample[200]  850. FFC_Eâ€¦ #> 2 2017 Q1 Melbourne Victorâ€¦ Visitiâ€¦  734.       1    77 sample[200]  762. FFC_Eâ€¦ #> 3 2017 Q2 Melbourne Victorâ€¦ Visitiâ€¦  670.       2    78 sample[200]  773. FFC_Eâ€¦ #> 4 2017 Q3 Melbourne Victorâ€¦ Visitiâ€¦  824.       3    79 sample[200]  741. FFC_Eâ€¦ #> 5 2017 Q4 Melbourne Victorâ€¦ Visitiâ€¦  985.       4    80 sample[200]  840. FFC_Eâ€¦ # Calculate accuracy metrics accuracy(fc_ffc, test) #> # A tibble: 1 Ã— 13 #>   .model  Region State Purpose .type    ME  RMSE   MAE     MPE  MAPE  MASE RMSSE #>   <chr>   <chr>  <chr> <chr>   <chr> <dbl> <dbl> <dbl>   <dbl> <dbl> <dbl> <dbl> #> 1 FFC_ETS Melboâ€¦ Victâ€¦ Visitiâ€¦ Test   10.1  91.0  80.9 -0.0453  9.94   NaN   NaN #> # â„¹ 1 more variable: ACF1 <dbl>  # Generate prediction intervals   fc_intervals <- hilo(fc_ffc, level = c(80, 95)) fc_intervals #> # A tsibble: 5 x 12 [1Q] #> # Key:       Region, State, Purpose [1] #>   Quarter Region    State   Purpose Trips quarter  time       .dist .mean .model #>     <qtr> <chr>     <chr>   <chr>   <dbl>   <int> <int>      <dist> <dbl> <chr>  #> 1 2016 Q4 Melbourne Victorâ€¦ Visitiâ€¦  804.       4    76 sample[200]  850. FFC_Eâ€¦ #> 2 2017 Q1 Melbourne Victorâ€¦ Visitiâ€¦  734.       1    77 sample[200]  762. FFC_Eâ€¦ #> 3 2017 Q2 Melbourne Victorâ€¦ Visitiâ€¦  670.       2    78 sample[200]  773. FFC_Eâ€¦ #> 4 2017 Q3 Melbourne Victorâ€¦ Visitiâ€¦  824.       3    79 sample[200]  741. FFC_Eâ€¦ #> 5 2017 Q4 Melbourne Victorâ€¦ Visitiâ€¦  985.       4    80 sample[200]  840. FFC_Eâ€¦ #> # â„¹ 2 more variables: `80%` <hilo>, `95%` <hilo>  # Distribution summaries fc_summary <- fc_ffc |>   summarise(     mean_forecast = mean(.dist),     median_forecast = median(.dist),     q25 = quantile(.dist, 0.25),      q75 = quantile(.dist, 0.75)   ) fc_summary #> # A tsibble: 5 x 5 [1Q] #>   Quarter mean_forecast median_forecast   q25   q75 #>     <qtr>         <dbl>           <dbl> <dbl> <dbl> #> 1 2016 Q4          850.            850.  795.  897. #> 2 2017 Q1          762.            759.  708.  810. #> 3 2017 Q2          773.            768.  730.  818. #> 4 2017 Q3          741.            738.  689.  789. #> 5 2017 Q4          840.            842.  773.  907. # Generate FFC forecasts with different models fc_ffc_arima <- as_fable(mod, newdata = test, model = \"ARIMA\") fc_ffc_ets <- as_fable(mod, newdata = test, model = \"ETS\")  # Generate traditional model forecasts fc_traditional <- train |>   model(     ARIMA = ARIMA(Trips),     ETS = ETS(Trips)   ) |>   forecast(h = 5)  # Calculate accuracy for all models acc_ffc_arima <- accuracy(fc_ffc_arima, test) acc_ffc_ets <- accuracy(fc_ffc_ets, test) acc_traditional <- accuracy(fc_traditional, test)  # Extract MAPE values for titles mape_ffc_arima <- round(acc_ffc_arima$MAPE, 1) mape_ffc_ets <- round(acc_ffc_ets$MAPE, 1) mape_arima <- round(acc_traditional$MAPE[acc_traditional$.model == \"ARIMA\"], 1) mape_ets <- round(acc_traditional$MAPE[acc_traditional$.model == \"ETS\"], 1)  # Create comparison plots library(patchwork)  p1 <- autoplot(fc_ffc_arima, train) +    geom_line(data = test, aes(y = Trips), color = \"black\") +   ggtitle(paste0(\"FFC with ARIMA (MAPE: \", mape_ffc_arima, \"%)\"))  p2 <- autoplot(fc_ffc_ets, train) +    geom_line(data = test, aes(y = Trips), color = \"black\") +   ggtitle(paste0(\"FFC with ETS (MAPE: \", mape_ffc_ets, \"%)\"))  p3 <- autoplot(filter(fc_traditional, .model == \"ARIMA\"), train) +   geom_line(data = test, aes(y = Trips), color = \"black\") +   ggtitle(paste0(\"Traditional ARIMA (MAPE: \", mape_arima, \"%)\"))  p4 <- autoplot(filter(fc_traditional, .model == \"ETS\"), train) +   geom_line(data = test, aes(y = Trips), color = \"black\") +   ggtitle(paste0(\"Traditional ETS (MAPE: \", mape_ets, \"%)\"))  (p1 | p2) / (p3 | p4)"},{"path":"https://nicholasjclark.github.io/ffc/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"ffc â€¢ Functional ForeCasting","text":"encounter clear bug, please file issue minimal reproducible example GitHub","code":""},{"path":"https://nicholasjclark.github.io/ffc/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"ffc â€¢ Functional ForeCasting","text":"Contributions welcome, please see Code Conduct considering changes like make.","code":""},{"path":"https://nicholasjclark.github.io/ffc/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"ffc â€¢ Functional ForeCasting","text":"ffc project licensed MIT open source license","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/ARDF.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an autoregressive dynamic factor model â€” ARDF","title":"Fit an autoregressive dynamic factor model â€” ARDF","text":"Fit autoregressive dynamic factor model using Stan","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/ARDF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an autoregressive dynamic factor model â€” ARDF","text":"","code":"ARDF(   formula,   family = gaussian(),   h = get_stan_param(\"h\", \"forecast\"),   chains = get_stan_param(\"chains\"),   cores = get_stan_param(\"cores\"),   iter = get_stan_param(\"iter\"),   warmup = floor(iter/2),   adapt_delta = get_stan_param(\"adapt_delta\"),   max_treedepth = get_stan_param(\"max_treedepth\"),   silent = get_stan_param(\"silent\"),   ... )"},{"path":"https://nicholasjclark.github.io/ffc/reference/ARDF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an autoregressive dynamic factor model â€” ARDF","text":"formula Model specification (see \"Specials\" section) family family object specifying outcome distribution use fitting. Currently gaussian() scat() (.e. Student-T) supported h integer specifying forecast horizon chains integer specifying number chains run cores integer specifying number parallel cores use iter integer specifying total number iterations run per chain (including warmup) warmup integer specifying number initial iterations use burnin adapt_delta thin jumps HMC method max_treedepth maximum tree depth per iteration silent Logical indicating whether suppress Stan sampling progress output. Default TRUE. FALSE, shows progress approximately every 10% iterations. ... arguments pass rstan::sampling()","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/ARDF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an autoregressive dynamic factor model â€” ARDF","text":"model specification","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/ARDF.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit an autoregressive dynamic factor model â€” ARDF","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/ARDF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an autoregressive dynamic factor model â€” ARDF","text":"","code":"# Fit a functional forecasting model, then use ARDF for forecasting library(dplyr) #>  #> Attaching package: â€˜dplyrâ€™ #> The following objects are masked from â€˜package:statsâ€™: #>  #>     filter, lag #> The following objects are masked from â€˜package:baseâ€™: #>  #>     intersect, setdiff, setequal, union  # Split growth data into training and test sets train_data <- growth_data |> filter(age_yr <= 13) test_data <- growth_data |> filter(age_yr > 13)  # Step 1: Fit ffc_gam model with time-varying coefficients mod <- ffc_gam(   height_cm ~     s(id, bs = \"re\") +     fts(age_yr, time_k = 5),   data = train_data,   time = \"age_yr\",   family = gaussian() )  # Step 2: Use ARDF for forecasting functional coefficients fc <- forecast(mod, newdata = test_data, model = \"ARDF\",                chains = 1, iter = 300) #> Warning: For Stan models, setting n_samples = 150 to match posterior samples. Requested n_samples = 200 would cause dimension mismatch. #> This warning is displayed once per session."},{"path":"https://nicholasjclark.github.io/ffc/reference/GPDF.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a GP dynamic factor model â€” GPDF","title":"Fit a GP dynamic factor model â€” GPDF","text":"Fit squared exponential GP dynamic factor model using Stan","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/GPDF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a GP dynamic factor model â€” GPDF","text":"","code":"GPDF(   formula,   family = gaussian(),   h = get_stan_param(\"h\", \"forecast\"),   chains = get_stan_param(\"chains\"),   cores = get_stan_param(\"cores\"),   iter = get_stan_param(\"iter\"),   warmup = floor(iter/2),   adapt_delta = get_stan_param(\"adapt_delta\"),   max_treedepth = get_stan_param(\"max_treedepth\"),   silent = get_stan_param(\"silent\"),   ... )"},{"path":"https://nicholasjclark.github.io/ffc/reference/GPDF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a GP dynamic factor model â€” GPDF","text":"formula Model specification (see \"Specials\" section) family family object specifying outcome distribution use fitting. Currently gaussian() scat() (.e. Student-T) supported h integer specifying forecast horizon chains integer specifying number chains run cores integer specifying number parallel cores use iter integer specifying total number iterations run per chain (including warmup) warmup integer specifying number initial iterations use burnin adapt_delta thin jumps HMC method max_treedepth maximum tree depth per iteration silent Logical indicating whether suppress Stan sampling progress output. Default TRUE. FALSE, shows progress approximately every 10% iterations. ... arguments pass rstan::sampling()","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/GPDF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a GP dynamic factor model â€” GPDF","text":"model specification","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/GPDF.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit a GP dynamic factor model â€” GPDF","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/GPDF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a GP dynamic factor model â€” GPDF","text":"","code":"# Fit a functional forecasting model, then use GPDF for forecasting library(dplyr)  # Split growth data into training and test sets train_data <- growth_data |> filter(age_yr <= 13) test_data <- growth_data |> filter(age_yr > 13)  # Step 1: Fit ffc_gam model with time-varying coefficients mod <- ffc_gam(   height_cm ~     s(id, bs = \"re\") +     fts(age_yr, time_k = 5),   data = train_data,   time = \"age_yr\",   family = gaussian() )  # Step 2: Use GPDF for forecasting functional coefficients fc <- forecast(mod, newdata = test_data, model = \"GPDF\",                chains = 1, iter = 300)"},{"path":"https://nicholasjclark.github.io/ffc/reference/VARDF.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Vector autoregressive dynamic factor model â€” VARDF","title":"Fit a Vector autoregressive dynamic factor model â€” VARDF","text":"Fit Vector autoregressive dynamic factor model using Stan","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/VARDF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Vector autoregressive dynamic factor model â€” VARDF","text":"","code":"VARDF(   formula,   family = gaussian(),   h = get_stan_param(\"h\", \"forecast\"),   chains = get_stan_param(\"chains\"),   cores = get_stan_param(\"cores\"),   iter = get_stan_param(\"iter\"),   warmup = floor(iter/2),   adapt_delta = get_stan_param(\"adapt_delta\"),   max_treedepth = get_stan_param(\"max_treedepth\"),   silent = get_stan_param(\"silent\"),   ... )"},{"path":"https://nicholasjclark.github.io/ffc/reference/VARDF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Vector autoregressive dynamic factor model â€” VARDF","text":"formula Model specification (see \"Specials\" section) family family object specifying outcome distribution use fitting. Currently gaussian() scat() (.e. Student-T) supported h integer specifying forecast horizon chains integer specifying number chains run cores integer specifying number parallel cores use iter integer specifying total number iterations run per chain (including warmup) warmup integer specifying number initial iterations use burnin adapt_delta thin jumps HMC method max_treedepth maximum tree depth per iteration silent Logical indicating whether suppress Stan sampling progress output. Default TRUE. FALSE, shows progress approximately every 10% iterations. ... arguments pass rstan::sampling()","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/VARDF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Vector autoregressive dynamic factor model â€” VARDF","text":"model specification","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/VARDF.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit a Vector autoregressive dynamic factor model â€” VARDF","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/VARDF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Vector autoregressive dynamic factor model â€” VARDF","text":"","code":"# Fit a functional forecasting model, then use VARDF for forecasting library(dplyr)  # Split growth data into training and test sets train_data <- growth_data |> filter(age_yr <= 13) test_data <- growth_data |> filter(age_yr > 13)  # Step 1: Fit ffc_gam model with time-varying coefficients mod <- ffc_gam(   height_cm ~     s(id, bs = \"re\") +     fts(age_yr, time_k = 5),   data = train_data,   time = \"age_yr\",   family = gaussian() )  # Step 2: Use VARDF for forecasting functional coefficients fc <- forecast(mod, newdata = test_data, model = \"VARDF\",                chains = 1, iter = 300)"},{"path":"https://nicholasjclark.github.io/ffc/reference/as_fable.ffc_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert ffc_gam forecasts to fable object â€” as_fable.ffc_gam","title":"Convert ffc_gam forecasts to fable object â€” as_fable.ffc_gam","text":"Convert ffc_gam forecasts fable object","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/as_fable.ffc_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert ffc_gam forecasts to fable object â€” as_fable.ffc_gam","text":"","code":"# S3 method for class 'ffc_gam' as_fable(   x,   newdata,   forecasts = NULL,   response = NULL,   model = \"ETS\",   key_vars = NULL,   ... )"},{"path":"https://nicholasjclark.github.io/ffc/reference/as_fable.ffc_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert ffc_gam forecasts to fable object â€” as_fable.ffc_gam","text":"x ffc_gam object used generate forecasts newdata data.frame containing forecast data response variable forecasts Optional pre-computed forecasts forecast.ffc_gam(). NULL, forecasts generated using remaining arguments response Character string specifying response variable name. NULL, automatically detected model formula model character string representing forecasting model use generating forecasts. Default \"ETS\" key_vars Optional character vector specifying grouping variables. NULL, automatically detected categorical variables newdata ... Additional arguments passed forecast.ffc_gam() generating forecasts","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/as_fable.ffc_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert ffc_gam forecasts to fable object â€” as_fable.ffc_gam","text":"fable x containing forecast distributions point estimates","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/as_fable.ffc_gam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert ffc_gam forecasts to fable object â€” as_fable.ffc_gam","text":"Converts forecasting output ffc_gam xs properly formatted fable x can used fabletools functions like autoplot(), accuracy(), forecast combination methods","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/reference/as_fable.ffc_gam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert ffc_gam forecasts to fable object â€” as_fable.ffc_gam","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/as_fable.ffc_gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert ffc_gam forecasts to fable object â€” as_fable.ffc_gam","text":"","code":"# Basic usage with automatic detection library(fable) #> Loading required package: fabletools library(tsibble) #>  #> Attaching package: â€˜tsibbleâ€™ #> The following objects are masked from â€˜package:baseâ€™: #>  #>     intersect, setdiff, union library(dplyr)  # Prepare tourism data tourism_melb <- tourism |>   filter(Region == \"Melbourne\", Purpose == \"Visiting\") |>   mutate(quarter = as.numeric(format(Quarter, \"%q\")),          time = row_number())  # Split data train <- tourism_melb |> slice_head(n = 75) test <- tourism_melb |> slice_tail(n = 5)  # Fit model mod <- ffc_gam(   Trips ~ fts(time, mean_only = TRUE, time_k = 50, time_m = 1) +           fts(quarter, k = 4, time_k = 15, time_m = 1),   time = \"time\", data = train, family = tw(), engine = \"gam\" )  # Convert to fable with auto-detection fc_fable <- as_fable(mod, newdata = test, model = \"ETS\")  # Use fabletools ecosystem autoplot(fc_fable, train)  # Forecast plot  accuracy(fc_fable, test)   # Accuracy metrics #> # A tibble: 1 Ã— 13 #>   .model  Region   State Purpose .type    ME  RMSE   MAE   MPE  MAPE  MASE RMSSE #>   <chr>   <chr>    <chr> <chr>   <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1 FFC_ETS Melbourâ€¦ Victâ€¦ Visitiâ€¦ Test   21.4  91.6  75.5  1.37  9.12   NaN   NaN #> # â„¹ 1 more variable: ACF1 <dbl> hilo(fc_fable, level = c(80, 95))  # Prediction intervals #> # A tsibble: 5 x 12 [1Q] #> # Key:       Region, State, Purpose [1] #>   Quarter Region    State   Purpose Trips quarter  time       .dist .mean .model #>     <qtr> <chr>     <chr>   <chr>   <dbl>   <dbl> <int>      <dist> <dbl> <chr>  #> 1 2016 Q4 Melbourne Victorâ€¦ Visitiâ€¦  804.       4    76 sample[200]  826. FFC_Eâ€¦ #> 2 2017 Q1 Melbourne Victorâ€¦ Visitiâ€¦  734.       1    77 sample[200]  754. FFC_Eâ€¦ #> 3 2017 Q2 Melbourne Victorâ€¦ Visitiâ€¦  670.       2    78 sample[200]  763. FFC_Eâ€¦ #> 4 2017 Q3 Melbourne Victorâ€¦ Visitiâ€¦  824.       3    79 sample[200]  741. FFC_Eâ€¦ #> 5 2017 Q4 Melbourne Victorâ€¦ Visitiâ€¦  985.       4    80 sample[200]  825. FFC_Eâ€¦ #> # â„¹ 2 more variables: `80%` <hilo>, `95%` <hilo>  # Distribution summaries fc_fable |>   summarise(     mean_forecast = mean(.dist),     q25 = quantile(.dist, 0.25),     q75 = quantile(.dist, 0.75)   ) #> # A tsibble: 5 x 4 [1Q] #>   Quarter mean_forecast   q25   q75 #>     <qtr>         <dbl> <dbl> <dbl> #> 1 2016 Q4          826.  770.  873. #> 2 2017 Q1          754.  715.  801. #> 3 2017 Q2          763.  715.  804. #> 4 2017 Q3          741.  694.  788. #> 5 2017 Q4          825.  777.  881.  # With pre-computed forecasts forecasts <- forecast(mod, newdata = test, model = \"ETS\", summary = FALSE) fc_fable2 <- as_fable(mod, newdata = test, forecasts = forecasts)  # With custom parameters fc_fable3 <- as_fable(   mod,   newdata = test,   model = \"ETS\",   response = \"Trips\",   key_vars = c(\"Region\", \"State\") )"},{"path":"https://nicholasjclark.github.io/ffc/reference/autoplot.fts_ts.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot time series of fts basis coefficients â€” autoplot.fts_ts","title":"Plot time series of fts basis coefficients â€” autoplot.fts_ts","text":"Produces time series plot basis function coefficients fts_ts objects","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/autoplot.fts_ts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot time series of fts basis coefficients â€” autoplot.fts_ts","text":"","code":"# S3 method for class 'fts_ts' autoplot(object, ...)"},{"path":"https://nicholasjclark.github.io/ffc/reference/autoplot.fts_ts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot time series of fts basis coefficients â€” autoplot.fts_ts","text":"object object class fts_ts containing time-varying basis function coefficients extracted ffc_gam object ... Ignored","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/autoplot.fts_ts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot time series of fts basis coefficients â€” autoplot.fts_ts","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/autoplot.fts_ts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot time series of fts basis coefficients â€” autoplot.fts_ts","text":"","code":"# Extract and plot time-varying coefficients mod <- ffc_gam(   deaths ~ offset(log(population)) + sex +      fts(age, k = 8, bs = \"cr\", time_k = 10),   time = \"year\",    data = qld_mortality,   family = poisson(),   engine = \"bam\" ) coefs <- fts_coefs(mod, summary = FALSE, n_samples = 5) autoplot(coefs)"},{"path":"https://nicholasjclark.github.io/ffc/reference/elnino_sst.html","id":null,"dir":"Reference","previous_headings":"","what":"El NiÃ±o Sea Surface Temperature Data â€” elnino_sst","title":"El NiÃ±o Sea Surface Temperature Data â€” elnino_sst","text":"Monthly sea surface temperature measurements El NiÃ±o regions 1 2 (OISST) spanning 1982-2018. data captures characteristic seasonal patterns inter-annual variability associated El NiÃ±o Southern Oscillation (ENSO) events.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/elnino_sst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"El NiÃ±o Sea Surface Temperature Data â€” elnino_sst","text":"","code":"elnino_sst"},{"path":"https://nicholasjclark.github.io/ffc/reference/elnino_sst.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"El NiÃ±o Sea Surface Temperature Data â€” elnino_sst","text":"tsibble 444 rows 3 columns: year Integer year 1982 2018 month Integer month 1 12 temperature Sea surface temperature degrees Celsius","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/elnino_sst.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"El NiÃ±o Sea Surface Temperature Data â€” elnino_sst","text":"Data originally rainbow::ElNino_OISST_region_1and2. OISST (Optimally Interpolated Sea Surface Temperature) data NOAA.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/elnino_sst.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"El NiÃ±o Sea Surface Temperature Data â€” elnino_sst","text":"dataset structured tsibble year index month key variable. format ideal functional forecasting seasonal patterns (monthly temperature curves) evolve years. El NiÃ±o regions 1 2 located eastern tropical Pacific Ocean critical monitoring ENSO events. Temperature anomalies regions strong predictors global climate patterns.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/elnino_sst.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"El NiÃ±o Sea Surface Temperature Data â€” elnino_sst","text":"Hyndman, R.J. Shang, H.L. (2010) Rainbow plots, bagplots, boxplots functional data. Journal Computational Graphical Statistics, 19(1), 29-45.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/elnino_sst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"El NiÃ±o Sea Surface Temperature Data â€” elnino_sst","text":"","code":"data(elnino_sst) head(elnino_sst) #> # A tsibble: 6 x 3 [1Y] #> # Key:       month [1] #>    year month temperature #>   <int> <int>       <dbl> #> 1  1982     1        24.3 #> 2  1983     1        27.4 #> 3  1984     1        24.2 #> 4  1985     1        23.6 #> 5  1986     1        24.6 #> 6  1987     1        25.3  # View seasonal patterns library(ggplot2) ggplot(elnino_sst, aes(x = month, y = temperature, group = year, color = year)) +   geom_line(alpha = 0.5) +   scale_color_viridis_c()"},{"path":"https://nicholasjclark.github.io/ffc/reference/ffc-package.html","id":null,"dir":"Reference","previous_headings":"","what":"ffc: Functional ForeCasting â€” ffc-package","title":"ffc: Functional ForeCasting â€” ffc-package","text":"Perform functional regression using Generalized Additive Models (GAMs) enable functional responses modelled predicted broad range predictor effects. package also handles functional predictors time-varying coefficients can forecasted ahead using variety efficient forecasting algorithms, providing unmatched flexibility model predict functional responses change time.","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/reference/ffc-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ffc: Functional ForeCasting â€” ffc-package","text":"Maintainer: Nicholas J Clark nicholas.j.clark1214@gmail.com (ORCID) contributors: KANK Karunarathna (ORCID) [contributor]","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/ffc_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a functional time series model using dynamic functional coefficients â€” ffc_gam","title":"Fit a functional time series model using dynamic functional coefficients â€” ffc_gam","text":"Fit Generalized Additive Models can include time-varying (dynamic) functions","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/ffc_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a functional time series model using dynamic functional coefficients â€” ffc_gam","text":"","code":"ffc_gam(   formula,   family = gaussian(),   data = list(),   time,   engine = c(\"gam\", \"bam\"),   ... )"},{"path":"https://nicholasjclark.github.io/ffc/reference/ffc_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a functional time series model using dynamic functional coefficients â€” ffc_gam","text":"formula GAM formula (see formula.gam also gam.models). exactly like formula GLM except smooth terms, fts(), s() te() can added right hand side specify linear predictor depends smooth functions predictors (linear functionals ). family family object specifying distribution link use fitting etc. See glm family details. extended families listed family.mgcv can also used. data data.frame containing variables model. Unlike gam, ffc_gam requires data data.frame support list data structures. time character specifying variable data represents time ordering observations engine character string specifying mgcv interface use fitting model. ... arguments pass either gam","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/ffc_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a functional time series model using dynamic functional coefficients â€” ffc_gam","text":"object class ffc_gam, inherits objects class gam bam. Use methods(class = \"ffc_gam\") see available methods.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/ffc_gam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a functional time series model using dynamic functional coefficients â€” ffc_gam","text":"function update supplied formula ensure time-varying functionals (supplied fts() terms formula right hand side) appropriately incorporated model. passes updated model data objects specified engine model fitting","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/reference/ffc_gam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit a functional time series model using dynamic functional coefficients â€” ffc_gam","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/ffc_gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a functional time series model using dynamic functional coefficients â€” ffc_gam","text":"","code":"# Fit a dynamic function-on-function regression to the Queensland # mortality data data(\"qld_mortality\") mod <- ffc_gam(   deaths ~     offset(log(population)) +     sex +     fts(age,       k = 8,       time_k = 10     ),   time = \"year\",   data = qld_mortality,   family = poisson(),   engine = \"bam\" ) class(mod) #> [1] \"ffc_gam\" \"bam\"     \"gam\"     \"glm\"     \"lm\"      summary(mod) #>  #> Family: poisson  #> Link function: log  #>  #> Formula: #> deaths ~ sex + offset(log(population)) + s(year, by = fts_bs_s_age__1,  #>     bs = \"ts\", k = 10, m = 2, id = 1) + s(year, by = fts_bs_s_age__2,  #>     bs = \"ts\", k = 10, m = 2, id = 1) + s(year, by = fts_bs_s_age__3,  #>     bs = \"ts\", k = 10, m = 2, id = 1) + s(year, by = fts_bs_s_age__4,  #>     bs = \"ts\", k = 10, m = 2, id = 1) + s(year, by = fts_bs_s_age__5,  #>     bs = \"ts\", k = 10, m = 2, id = 1) + s(year, by = fts_bs_s_age__6,  #>     bs = \"ts\", k = 10, m = 2, id = 1) + s(year, by = fts_bs_s_age__7,  #>     bs = \"ts\", k = 10, m = 2, id = 1) #>  #> Parametric coefficients: #>              Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -5.553606   0.002381 -2332.6   <2e-16 *** #> sexmale      0.472665   0.002077   227.6   <2e-16 *** #> --- #> Signif. codes:  0 â€˜***â€™ 0.001 â€˜**â€™ 0.01 â€˜*â€™ 0.05 â€˜.â€™ 0.1 â€˜ â€™ 1 #>  #> Approximate significance of smooth terms: #>                           edf Ref.df Chi.sq p-value     #> s(year):fts_bs_s_age__1 8.165     10  22396  <2e-16 *** #> s(year):fts_bs_s_age__2 6.829     10  15647  <2e-16 *** #> s(year):fts_bs_s_age__3 8.112     10   2883  <2e-16 *** #> s(year):fts_bs_s_age__4 7.085     10  14643  <2e-16 *** #> s(year):fts_bs_s_age__5 7.847     10    707  <2e-16 *** #> s(year):fts_bs_s_age__6 5.923     10  23037  <2e-16 *** #> s(year):fts_bs_s_age__7 6.259     10   8424  <2e-16 *** #> --- #> Signif. codes:  0 â€˜***â€™ 0.001 â€˜**â€™ 0.01 â€˜*â€™ 0.05 â€˜.â€™ 0.1 â€˜ â€™ 1 #>  #> R-sq.(adj) =  0.972   Deviance explained = 94.7% #> fREML =  46558  Scale est. = 1         n = 8282  # Distributional regression with gaulss() family # Simulated data with time-varying location and scale library(mgcv) #> Loading required package: nlme #>  #> Attaching package: â€˜nlmeâ€™ #> The following object is masked from â€˜package:dplyrâ€™: #>  #>     collapse #> This is mgcv 1.9-3. For overview type 'help(\"mgcv-package\")'. set.seed(1234) n <- 50 sim_data <- data.frame(   time = 1:n,   x = rnorm(n),   y = rnorm(n, mean = sin(2 * pi * (1:n) / 20),              sd = 0.5 + 0.3 * cos(2 * pi * (1:n) / 15)) )  # Fit distributional model with time-varying parameters dist_mod <- ffc_gam(   list(     y ~ fts(x, k = 5),      # Location parameter     ~ fts(x, k = 3)         # Scale parameter     ),   family = gaulss(),   data = sim_data,   time = \"time\" ) #> Warning: Shared penalties may cause fitting issues with distributional families. Setting {.field share_penalty} = FALSE. #> This warning is displayed once per session.  # Extract parameter-specific coefficients coefs <- fts_coefs(dist_mod) print(unique(coefs$.parameter))  # Shows \"location\" and \"scale\" #> [1] \"location\" \"scale\"     # Extract and visualize time-varying coefficients coefs <- fts_coefs(mod, summary = FALSE, n_samples = 5) autoplot(coefs)   # Forecast future mortality patterns future_data <- expand.grid(   age = unique(qld_mortality$age),   sex = unique(qld_mortality$sex),   year = 2021:2025,   # Use rate scale (to predict deaths per person)   population = 1 )  # Generate forecasts using ETS model for coefficients mortality_fc <- forecast(mod, newdata = future_data, model = \"ETS\",                          type = \"expected\") head(mortality_fc) #> # A tibble: 6 Ã— 6 #>   .estimate  .error    .q2.5     .q10     .q90   .q97.5 #>       <dbl>   <dbl>    <dbl>    <dbl>    <dbl>    <dbl> #> 1  0.00115  0.00119 0.000997 0.00104  0.00130  0.00138  #> 2  0.00102  0.00132 0.000883 0.000936 0.00115  0.00120  #> 3  0.000904 0.00147 0.000759 0.000822 0.00105  0.00111  #> 4  0.000804 0.00152 0.000694 0.000736 0.000913 0.00104  #> 5  0.000714 0.00160 0.000616 0.000658 0.000823 0.000894 #> 6  0.000638 0.00168 0.000545 0.000578 0.000728 0.000812"},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.ffc_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecasting ffc_gam models â€” forecast.ffc_gam","title":"Forecasting ffc_gam models â€” forecast.ffc_gam","text":"Forecasting ffc_gam models","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.ffc_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecasting ffc_gam models â€” forecast.ffc_gam","text":"","code":"# S3 method for class 'ffc_gam' forecast(   object,   newdata,   type = \"response\",   model = \"ENS\",   stationary = FALSE,   summary = TRUE,   robust = TRUE,   probs = c(0.025, 0.1, 0.9, 0.975),   mean_model = \"ENS\",   ... )"},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.ffc_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecasting ffc_gam models â€” forecast.ffc_gam","text":"object object class ffc_gam. See ffc_gam() newdata dataframe list test data containing variables included original data used fit model. covariate information newdata, along temporal information indexed time variable original call ffc_gam(), used generate forecasts fitted model equations type value link, linear predictor calculated link scale. expected used, predictions reflect expectation response (mean) ignore uncertainty observation process. response used (default), predictions take uncertainty observation process account return predictions outcome scale model character string specifying forecasting model use. Default \"ENS\" (ensemble). Options include \"ENS\", \"ETS\", \"ARIMA\", \"RW\", \"NAIVE\", Stan dynamic factor models (\"ARDF\", \"VARDF\", \"GPDF\"). \"ENS\" combines ETS Random Walk forecasts equal weights, hedging bets different forecasting assumptions improve robustness. stationary TRUE, fitted time series models constrained stationary. Default FALSE. option works model == 'ARIMA' summary summary statistics returned instead raw values? Default TRUE robust FALSE (default) mean used measure central tendency standard deviation measure variability. TRUE, median median absolute deviation (MAD) applied instead. used summary TRUE probs percentiles computed quantile() function. used summary TRUE mean_model character string specifying forecasting model use mean basis coefficients using Stan factor models (ARDF, VARDF, GPDF). Default \"ENS\". Options include \"ENS\", \"ETS\", \"ARIMA\", \"RW\", \"NAIVE\". \"ENS\" creates ensemble ETS RW forecasts equal weights, hedging bets different forecasting assumptions mean coefficients. used forecasting mixed mean/non-mean basis functions Stan factor models. ... Additional arguments Stan dynamic factor models (ARDF, VARDF, GPDF). Key arguments include: n_samples (number forecast samples, default: 200), K (number factors, default: 2), lag (AR order, default: 1), chains (MCMC chains, default: 4), iter (iterations, default: 500), silent (suppress progress, default: TRUE), cores, adapt_delta, max_treedepth.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.ffc_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecasting ffc_gam models â€” forecast.ffc_gam","text":"Predicted values appropriate scale. summary == FALSE, output matrix. summary == TRUE, output tidy tbl_df / data.frame","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.ffc_gam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Forecasting ffc_gam models â€” forecast.ffc_gam","text":"Distributional Family Support: Full support distributional regression models using mgcv families: gaulss: Gaussian location-scale (normal distribution varying mean variance) twlss: Tweedie location-scale-shape distributional families, forecasting operates parameters simultaneously, producing forecasts capture mean variance dynamics time. Forecasting Methodology: function implements two-stage forecasting approach functional regression models time-varying coefficients form: $$y_t = \\sum_{j=1}^{J} \\beta_j(t) B_j(x) + \\epsilon_t$$ \\(\\beta_j(t)\\) time-varying coefficients \\(B_j(x)\\) basis functions. Extract basis coefficients: Time-varying functional coefficients \\(\\beta_j(t)\\) extracted fitted GAM time series Forecast coefficients: coefficient time series forecast using ensemble methods (ENS), Stan dynamic factor models (ARDF/VARDF/GPDF), individual fable models (ETS, ARIMA, etc.) Reconstruct forecasts: Forecasted coefficients combined: $$\\hat{y}_{t+h} = \\sum_{j=1}^{J} \\hat{\\beta}_j(t+h) B_j(x)$$ Combine uncertainties: Multiple uncertainty sources integrated hierarchically (see Uncertainty Quantification section) Uncertainty Quantification: Forecast uncertainty captured hierarchical structure: Within Stan dynamic factor models: Process uncertainty: Factor dynamics, autoregressive terms, factor loadings Observation uncertainty: Series-specific error terms (\\(\\sigma_{obs}\\)) Final combination linear predictor space: Stan forecast samples: Already incorporate process + observation uncertainty GAM parameter uncertainty: Random draws \\(N(\\hat{\\boldsymbol{\\theta}}, \\mathbf{V})\\) \\(\\mathbf{V}\\) coefficient covariance matrix components combined additively: \\(\\text{Stan forecasts} + \\text{GAM uncertainty}\\) Model Selection: ENS ensemble (default): Combines ETS Random Walk forecasts equal weights. hedges bets exponential smoothing assumptions (trend seasonality patterns continue) random walk assumptions (future values equal current values). Provides robust predictions model uncertainty high, common coefficient forecasting. Stan factor models (ARDF/VARDF/GPDF): Used multivariate forecasting non-mean basis coefficients. Capture dependencies coefficient series assume zero-centered time series efficiency. Mean basis models: Used mean basis coefficients (operate non-zero levels). Default ENS ensemble, controlled mean_model parameter. Important Note n_samples Parameter: Stan dynamic factor models, n_samples parameter automatically set (iter - warmup) * chains ensure dimensional consistency. user-specified n_samples value ignored warning. ARIMA models, n_samples can specified freely controls number posterior draws.","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.ffc_gam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Forecasting ffc_gam models â€” forecast.ffc_gam","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.ffc_gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forecasting ffc_gam models â€” forecast.ffc_gam","text":"","code":"# Basic forecasting example with growth data data(\"growth_data\") mod <- ffc_gam(   height_cm ~ s(id, bs = \"re\") +     fts(age_yr, k = 8, bs = \"cr\", time_k = 10),   time = \"age_yr\",   data = growth_data,   family = Gamma() )  # Forecast with ETS model newdata <- data.frame(   id = \"boy_11\",   age_yr = c(16, 17, 18) ) fc <- forecast(mod, newdata = newdata)  # Uses ENS ensemble by default  # Forecast with specific models fc_ets <- forecast(mod, newdata = newdata, model = \"ETS\") fc_rw <- forecast(mod, newdata = newdata, model = \"RW\")  # Get raw forecast matrix without summary fc_raw <- forecast(mod, newdata = newdata, summary = FALSE)  # Distributional regression forecasting example library(mgcv) set.seed(123) n <- 50 dist_data <- data.frame(   time = 1:n,   x = rnorm(n),   y = rnorm(n, mean = sin(2 * pi * (1:n) / 10)) )  # Fit distributional model dist_mod <- ffc_gam(   list(     y ~ fts(x, k = 4),     ~ fts(x, k = 3)   ),   family = gaulss(),   data = dist_data,   time = \"time\" )  # Forecast distributional model new_dist_data <- data.frame(time = (n+1):(n+3), x = rnorm(3)) dist_fc <- forecast(dist_mod, newdata = new_dist_data) # Contains prediction intervals accounting for both parameters print(dist_fc) #> # A tibble: 3 Ã— 6 #>   .estimate .error .q2.5  .q10  .q90 .q97.5 #>       <dbl>  <dbl> <dbl> <dbl> <dbl>  <dbl> #> 1    0.0690  0.665 -1.84 -1.32  1.39   2.11 #> 2   -0.0113  0.732 -1.77 -1.10  1.52   2.28 #> 3    0.135   0.722 -1.81 -1.12  1.41   2.22"},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.fts_ts.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecasting functional basis coefficients (Internal) â€” forecast.fts_ts","title":"Forecasting functional basis coefficients (Internal) â€” forecast.fts_ts","text":"internal use: function primarily used internally forecast.ffc_gam(). users call forecast() directly ffc_gam object instead using function, requires properly structured coefficient data specific format requirements.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.fts_ts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecasting functional basis coefficients (Internal) â€” forecast.fts_ts","text":"","code":"# S3 method for class 'fts_ts' forecast(   object,   model = \"ARIMA\",   h = get_stan_param(\"h\", \"forecast\"),   n_samples = 25,   stationary = FALSE,   ... )"},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.fts_ts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecasting functional basis coefficients (Internal) â€” forecast.fts_ts","text":"object object class fts_ts containing time-varying basis function coefficients extracted ffc_gam object using fts_coefs() model character string representing valid univariate model definition fable package, ensemble methods, one built-Bayesian dynamic factor models. Note fable model used, chosen method must associated generate() method order simulate forecast realisations. Valid models currently include: 'ENS', 'ARDF', 'GPDF', 'VARDF, 'ETS', 'ARIMA', 'AR', 'RW', 'NAIVE', 'NNETAR'. 'ENS' option combines ETS Random Walk forecasts equal weights, hedging bets exponential smoothing random walk assumptions provide robust predictions model uncertainty high. h positive integer specifying length forecast horizon n_samples positive integer specifying number forecast realisation paths simulate fitted forecast model stationary TRUE, fitted time series models constrained stationary. Default FALSE. option works model == 'ARIMA' ... arguments pass Stan dynamic factor models (.e. (V)AR order lag = ... number factors K = ...)","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.fts_ts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecasting functional basis coefficients (Internal) â€” forecast.fts_ts","text":"tsibble object containing forecast prediction (.sim) replicate realisation (.rep) timestep forecast horizon h","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.fts_ts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Forecasting functional basis coefficients (Internal) â€” forecast.fts_ts","text":"Basis function coefficient time series used input specified model train forecasting model extrapolated h timesteps future. total times forecast realisations returned basis coefficient","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.fts_ts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Forecasting functional basis coefficients (Internal) â€” forecast.fts_ts","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/forecast.fts_ts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forecasting functional basis coefficients (Internal) â€” forecast.fts_ts","text":"","code":"# Extract coefficients and generate forecasts mod <- ffc_gam(   deaths ~ offset(log(population)) + sex +     fts(age, k = 8, bs = \"cr\", time_k = 10),   time = \"year\",   data = qld_mortality,   family = poisson(),   engine = \"bam\" ) coefs <- fts_coefs(mod, summary = FALSE, n_samples = 5)  # Generate ETS forecasts forecast(coefs, model = \"ETS\", h = 3) #> # A tsibble: 2,625 x 6 [1Y] #> # Key:       .basis, .realisation, .model, .rep [875] #>    .basis          .realisation .model  year .rep   .sim #>    <chr>                  <int> <chr>  <dbl> <chr> <dbl> #>  1 fts_bs_s_age__1            1 ETS     2021 1     -1.93 #>  2 fts_bs_s_age__1            1 ETS     2022 1     -1.90 #>  3 fts_bs_s_age__1            1 ETS     2023 1     -1.86 #>  4 fts_bs_s_age__1            1 ETS     2021 10    -1.93 #>  5 fts_bs_s_age__1            1 ETS     2022 10    -1.88 #>  6 fts_bs_s_age__1            1 ETS     2023 10    -1.83 #>  7 fts_bs_s_age__1            1 ETS     2021 11    -1.92 #>  8 fts_bs_s_age__1            1 ETS     2022 11    -1.88 #>  9 fts_bs_s_age__1            1 ETS     2023 11    -1.84 #> 10 fts_bs_s_age__1            1 ETS     2021 12    -1.93 #> # â„¹ 2,615 more rows"},{"path":"https://nicholasjclark.github.io/ffc/reference/fts.html","id":null,"dir":"Reference","previous_headings":"","what":"Define functions with dynamic coefficients in ffc formulae â€” fts","title":"Define functions with dynamic coefficients in ffc formulae â€” fts","text":"Set smooth terms time-varying (dynamic) coefficients use ffc models","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/fts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define functions with dynamic coefficients in ffc formulae â€” fts","text":"","code":"fts(   ...,   mean_only = FALSE,   k = NA,   time_k = 10,   bs = \"cr\",   time_bs = \"ts\",   m = NA,   time_m = 2,   share_penalty = TRUE,   d = NA,   by = NA,   xt = NULL,   pc = NULL )"},{"path":"https://nicholasjclark.github.io/ffc/reference/fts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define functions with dynamic coefficients in ffc formulae â€” fts","text":"... list variables covariates smooth function . Transformations whose form depends values data best avoided : e.g. fts(log(x), z) fine, fts((x / sd(x)), z) . mean_only Logical indicating whether include single basis function modelled time-varying. can helpful wish include temporal trend can forecasted ahead using appropriate time series models. Default FALSE k dimension(s) bases used represent smooth term. supplied set either 10 (single covariate supplied) 5 ^ d, d number covariates supplied. supplied single number basis dimension used basis. supplied array elements dimensions component (marginal) bases tensor product. time_k dimension bases used time-varying coefficient smooths (see Details ). Arbitrarily set 10 default. bs array (single character string) specifying type marginal basis. \"cr\" cubic regression spline; \"cs\" cubic regression spline shrinkage; \"cc\" periodic/cyclic cubic regression spline; \"tp\" thin plate regression spline; \"ts\" t.p.r.s. extra shrinkage. See smooth.terms details full list. User defined bases can also used (see smooth.construct example). one basis code given used bases. time_bs two letter character string indicating (penalized) smoothing basis use time-varying basis coefficients (eg \"tp\" thin plate regression spline, \"cr\" cubic regression spline). see smooth.terms view available. generally recommended stick one doubly-penalized bases (.e. \"cs\" \"ts\") helps ensure resulting basis function coefficient time series estimated appropriate scale later forecasting m order spline penalty (smooth classes use ) term.    single number given  used terms. vector can used   supply different m margin. marginals take vector m   (e.g. p.spline Duchon.spline),   list can supplied, vector element margin. NA autoinitializes.   m ignored bases (e.g. \"cr\"). time_m order penalty time-varying coefficient smooths (e.g. 2 normal cubic spline penalty 2nd derivatives). smooth classes use . \"ps\" class can use 2 item array giving basis penalty order separately. share_penalty logical specifying whether time-varying coefficient smooths term share smoothing penalty. Defaults TRUE single-parameter families, automatically set FALSE distributional families (list formulae) prevent mgcv fitting issues. Changing FALSE gives flexibility capture time-varying functions. d array marginal basis dimensions. example want smooth 3 covariates made tensor product 2 dimensional t.p.r.s. basis 1-dimensional basis, set d=c(2,1). Incompatibilities built basis types dimension resolved resetting basis type. factor variable dimension covariate, used create replicate smooth factor level. xt Either single object, providing extra information passed marginal basis constructor, list objects, one marginal basis. pc NULL, signals point constraint: smooth pass zero point given (vector list names corresponding smooth names). Never ignored supplied. See identifiability.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/fts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define functions with dynamic coefficients in ffc formulae â€” fts","text":"class fts.spec object defining smooth function evaluated configured estimating time-varying basis function coefficients","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/fts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define functions with dynamic coefficients in ffc formulae â€” fts","text":"ffc evaluate basis smooths add basis functions internal model design matrix. basis function predictors added data, model estimated allows coefficients change time using terms s(time, = bfun_1, id = 1, bs = 'cr') + s(time, = bfun_2, id = 1, bs = 'cr') + .... linking smoothing parameters using id argument, time-varying function efficiently regularised.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/fts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Define functions with dynamic coefficients in ffc formulae â€” fts","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/fts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define functions with dynamic coefficients in ffc formulae â€” fts","text":"","code":"# Define a time-varying smooth function of age fts(age, k = 8, bs = \"cr\", time_k = 10) #> $call #> [1] \"s(age, k = 8, bs = \\\"cr\\\")\" #>  #> $term #> [1] \"age\" #>  #> $by #> [1] \"NA\" #>  #> $time_bs #> [1] \"ts\" #>  #> $time_k #> [1] 10 #>  #> $time_m #> [1] 2 #>  #> $label #> [1] \"fts_age\" #>  #> $mean_only #> [1] FALSE #>  #> $share_penalty #> [1] TRUE #>"},{"path":"https://nicholasjclark.github.io/ffc/reference/fts_coefs.ffc_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract time-varying basis coefficients â€” fts_coefs.ffc_gam","title":"Extract time-varying basis coefficients â€” fts_coefs.ffc_gam","text":"Extract time-varying basis coefficients fitted ffc_gam model can visualized / forecasted ahead","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/fts_coefs.ffc_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract time-varying basis coefficients â€” fts_coefs.ffc_gam","text":"","code":"fts_coefs(object, ...)  # S3 method for class 'ffc_gam' fts_coefs(object, summary = TRUE, n_samples = 25, ...)"},{"path":"https://nicholasjclark.github.io/ffc/reference/fts_coefs.ffc_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract time-varying basis coefficients â€” fts_coefs.ffc_gam","text":"object list object class ffc_gam. See ffc_gam() ... Ignored summary Logical. summary statistics coefficient time series returned instead realized curves? Default TRUE. FALSE, replicate realisations basis coefficient time series returned n_samples positive integer specifying number time series realisation paths simulate fitted model. Ignored summary = FALSE","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/fts_coefs.ffc_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract time-varying basis coefficients â€” fts_coefs.ffc_gam","text":"fts_ts object containing point estimates standard errors basis function coefficients","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/fts_coefs.ffc_gam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract time-varying basis coefficients â€” fts_coefs.ffc_gam","text":"function creates tidy time series basis function coefficients fts() terms supplied original model","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/reference/fts_coefs.ffc_gam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract time-varying basis coefficients â€” fts_coefs.ffc_gam","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/growth_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Berkeley growth study data â€” growth_data","title":"Berkeley growth study data â€” growth_data","text":"dataset containing heights 39 boys measured ages 3 15 years regular yearly intervals. subset original Berkeley Growth Study data filtered contain regular time intervals suitable time series modeling.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/growth_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Berkeley growth study data â€” growth_data","text":"","code":"growth_data"},{"path":"https://nicholasjclark.github.io/ffc/reference/growth_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Berkeley growth study data â€” growth_data","text":"data.frame 507 observations 3 variables: height_cm numeric height, centimeters age_yr numeric age boys measured, years (3, 4, 5, ..., 15) id factor indicating different subjects (39 boys)","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/growth_data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Berkeley growth study data â€” growth_data","text":"Tuddenham, R. D., Snyder, M. M. (1954) \"Physical growth California boys girls birth age 18\", University California Publications Child Development, 1, 183-364.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/model.frame.ffc_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract model.frame from a fitted ffc_gam object â€” model.frame.ffc_gam","title":"Extract model.frame from a fitted ffc_gam object â€” model.frame.ffc_gam","text":"Extract model.frame fitted ffc_gam object","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/model.frame.ffc_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract model.frame from a fitted ffc_gam object â€” model.frame.ffc_gam","text":"","code":"# S3 method for class 'ffc_gam' model.frame(formula, ...)"},{"path":"https://nicholasjclark.github.io/ffc/reference/model.frame.ffc_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract model.frame from a fitted ffc_gam object â€” model.frame.ffc_gam","text":"formula model formula terms     object R object. ... Ignored","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/model.frame.ffc_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract model.frame from a fitted ffc_gam object â€” model.frame.ffc_gam","text":"matrix containing fitted model frame","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/model.frame.ffc_gam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract model.frame from a fitted ffc_gam object â€” model.frame.ffc_gam","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/predict.ffc_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict from a fitted ffc_gam model â€” predict.ffc_gam","title":"Predict from a fitted ffc_gam model â€” predict.ffc_gam","text":"Predict fitted ffc_gam model","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/predict.ffc_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict from a fitted ffc_gam model â€” predict.ffc_gam","text":"","code":"# S3 method for class 'ffc_gam' predict(object, newdata, type = \"link\", se.fit = FALSE, ...)"},{"path":"https://nicholasjclark.github.io/ffc/reference/predict.ffc_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict from a fitted ffc_gam model â€” predict.ffc_gam","text":"object fitted gam object produced gam(). newdata data frame list containing values model covariates predictions   required. provided predictions corresponding                 original data returned. newdata provided                 contain variables needed prediction:                 warning generated . See details use link{linear.functional.terms}. type value \"link\" (default) linear predictor (possibly associated standard errors) returned. type=\"terms\" component linear predictor returned seperately (possibly standard errors): includes parametric model components, followed smooth component, excludes offset intercept. type=\"iterms\" , except standard errors returned smooth components include uncertainty intercept/overall mean.  type=\"response\" predictions scale response returned (possibly approximate standard errors). type=\"lpmatrix\" matrix returned yields values linear predictor (minus offset) postmultiplied parameter vector (case se.fit ignored). latter option useful getting variance estimates quantities derived model: example integrated quantities, derivatives smooths. linear predictor matrix can also used implement approximate prediction outside R (see example code, ). se.fit TRUE (default) standard error estimates returned prediction. ... ignored","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/predict.ffc_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict from a fitted ffc_gam model â€” predict.ffc_gam","text":"type == \"lpmatrix\" matrix returned give vector linear predictor values (minus offest) supplied covariate values, applied model coefficient vector. Otherwise, se.fit == TRUE 2 item list returned items (arrays) fit se.fit containing predictions associated standard error estimates, otherwise array predictions returned. dimensions returned arrays depends whether type \"terms\" : array 2 dimensional term linear predictor separate, otherwise array 1 dimensional contains linear predictor/predicted values (corresponding s.e.s). linear predictor returned termwise include offset intercept.","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/predict.ffc_gam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict from a fitted ffc_gam model â€” predict.ffc_gam","text":"function returns predictions models fitted ffc_gam(). Data passed newdata first correctly augmented include basis functions whose coefficients estimated time-varying, user need supply data includes variables used original data supplied ffc_gam()","code":""},{"path":[]},{"path":"https://nicholasjclark.github.io/ffc/reference/predict.ffc_gam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Predict from a fitted ffc_gam model â€” predict.ffc_gam","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/predict.ffc_gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict from a fitted ffc_gam model â€” predict.ffc_gam","text":"","code":"# Fit a model and generate predictions mod <- ffc_gam(   deaths ~ offset(log(population)) + sex +      fts(age, k = 8, bs = \"cr\", time_k = 10),   time = \"year\",    data = qld_mortality,   family = poisson(),   engine = \"bam\" ) preds <- predict(mod, type = \"response\")  # Distributional regression prediction library(mgcv) set.seed(42) n <- 40 sim_data <- data.frame(   time = 1:n,   x = rnorm(n),    y = rnorm(n) ) dist_mod <- ffc_gam(   list(y ~ fts(x, k = 4), ~ fts(x, k = 3)),   family = gaulss(),    data = sim_data,   time = \"time\" ) # Returns expected values (location parameter) for distributional families dist_preds <- predict(dist_mod, type = \"response\")"},{"path":"https://nicholasjclark.github.io/ffc/reference/print.fts_ts.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an fts_ts tibble â€” print.fts_ts","title":"Print an fts_ts tibble â€” print.fts_ts","text":"Print fts_ts tibble","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/print.fts_ts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an fts_ts tibble â€” print.fts_ts","text":"","code":"# S3 method for class 'fts_ts' print(x, ...)"},{"path":"https://nicholasjclark.github.io/ffc/reference/print.fts_ts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print an fts_ts tibble â€” print.fts_ts","text":"x object class fts_ts ... Ignored","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/print.fts_ts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print an fts_ts tibble â€” print.fts_ts","text":"Nicholas J Clark","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/qld_mortality.html","id":null,"dir":"Reference","previous_headings":"","what":"Queensland mortality data â€” qld_mortality","title":"Queensland mortality data â€” qld_mortality","text":"dataset containing number deaths, population risk ages residents Queensland, Australia 1979 2020","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/qld_mortality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Queensland mortality data â€” qld_mortality","text":"","code":"qld_mortality"},{"path":"https://nicholasjclark.github.io/ffc/reference/qld_mortality.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Queensland mortality data â€” qld_mortality","text":"data.frame containing following fields: year integer, year records age integer, age death, years sex factor differentiating sexes deaths integer, number deaths recorded population numeric population recorded 30 June year","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/qld_mortality.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Queensland mortality data â€” qld_mortality","text":"Australian Human Mortality Database","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/qld_mortality.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Queensland mortality data â€” qld_mortality","text":"age group 100 also includes people died aged older 100. data come Australian Human Mortality Database (https://aushd.org).","code":""},{"path":"https://nicholasjclark.github.io/ffc/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages â€” reexports","title":"Objects exported from other packages â€” reexports","text":"objects imported packages. Follow links see documentation. generics forecast, generate ggplot2 autoplot mgcv bam, betar, cnorm, gam, ldTweedie, multinom, nb, negbin, ocat, rTweedie, s, scat, te, tw, twlss, ziP","code":""}]
